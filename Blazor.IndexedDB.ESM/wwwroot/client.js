var I=(s,e)=>e.some(t=>s instanceof t),S,D;function k(){return S||(S=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function O(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}var p=new WeakMap,f=new WeakMap,g=new WeakMap;function j(s){let e=new Promise((t,r)=>{let n=()=>{s.removeEventListener("success",o),s.removeEventListener("error",a)},o=()=>{t(l(s.result)),n()},a=()=>{r(s.error),n()};s.addEventListener("success",o),s.addEventListener("error",a)});return g.set(e,s),e}function K(s){if(p.has(s))return;let e=new Promise((t,r)=>{let n=()=>{s.removeEventListener("complete",o),s.removeEventListener("error",a),s.removeEventListener("abort",a)},o=()=>{t(),n()},a=()=>{r(s.error||new DOMException("AbortError","AbortError")),n()};s.addEventListener("complete",o),s.addEventListener("error",a),s.addEventListener("abort",a)});p.set(s,e)}var R={get(s,e,t){if(s instanceof IDBTransaction){if(e==="done")return p.get(s);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return l(s[e])},set(s,e,t){return s[e]=t,!0},has(s,e){return s instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in s}};function P(s){R=s(R)}function A(s){return O().includes(s)?function(...e){return s.apply(x(this),e),l(this.request)}:function(...e){return l(s.apply(x(this),e))}}function M(s){return typeof s=="function"?A(s):(s instanceof IDBTransaction&&K(s),I(s,k())?new Proxy(s,R):s)}function l(s){if(s instanceof IDBRequest)return j(s);if(f.has(s))return f.get(s);let e=M(s);return e!==s&&(f.set(s,e),g.set(e,s)),e}var x=s=>g.get(s);function w(s,e,{blocked:t,upgrade:r,blocking:n,terminated:o}={}){let a=indexedDB.open(s,e),u=l(a);return r&&a.addEventListener("upgradeneeded",i=>{r(l(a.result),i.oldVersion,i.newVersion,l(a.transaction),i)}),t&&a.addEventListener("blocked",i=>t(i.oldVersion,i.newVersion,i)),u.then(i=>{o&&i.addEventListener("close",()=>o()),n&&i.addEventListener("versionchange",c=>n(c.oldVersion,c.newVersion,c))}).catch(()=>{}),u}function $(s,{blocked:e}={}){let t=indexedDB.deleteDatabase(s);return e&&t.addEventListener("blocked",r=>e(r.oldVersion,r)),l(t).then(()=>{})}var T=["get","getKey","getAll","getAllKeys","count"],q=["put","add","delete","clear"],b=new Map;function v(s,e){if(!(s instanceof IDBDatabase&&!(e in s)&&typeof e=="string"))return;if(b.get(e))return b.get(e);let t=e.replace(/FromIndex$/,""),r=e!==t,n=q.includes(t);if(!(t in(r?IDBIndex:IDBObjectStore).prototype)||!(n||T.includes(t)))return;let o=async function(a,...u){let i=this.transaction(a,n?"readwrite":"readonly"),c=i.store;return r&&(c=c.index(u.shift())),(await Promise.all([c[t](...u),n&&i.done]))[0]};return b.set(e,o),o}P(s=>({...s,get:(e,t,r)=>v(e,t)||s.get(e,t,r),has:(e,t)=>!!v(e,t)||s.has(e,t)}));var L=["continue","continuePrimaryKey","advance"],C={},B=new WeakMap,Q=new WeakMap,V={get(s,e){if(!L.includes(e))return s[e];let t=C[e];return t||(t=C[e]=function(...r){B.set(this,Q.get(this)[e](...r))}),t}};async function*_(...s){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...s)),!e)return;e=e;let t=new Proxy(e,V);for(Q.set(t,e),g.set(t,x(e));e;)yield t,e=await(B.get(t)||e.continue()),B.delete(t)}function E(s,e){return e===Symbol.asyncIterator&&I(s,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&I(s,[IDBIndex,IDBObjectStore])}P(s=>({...s,get(e,t,r){return E(e,t)?_:s.get(e,t,r)},has(e,t){return E(e,t)||s.has(e,t)}}));var F="RaiseNotificationFromJS",m=class{instances=[];_dbManagerRef;_sendNotifications=!1;constructor(e){this._dbManagerRef=e.dotNetReference,this._sendNotifications=e.sendNotificationsFromJS}async openDb(e){let t=[],r=this.getInstance(e.name);try{if(!r||r.instance.version<e.version){r&&(r.instance.close(),this.instances.splice(this.instances.indexOf(r),1));let n=await w(e.name,e.version,{upgrade:async(o,a,u,i)=>{let c=this.upgradeDatabase(o,e,a,u,i);await i.done,t.push(...c)},blocked:async(o,a,u)=>{let i=`Database upgrade blocked. Current version: ${o}, Blocked version: ${a}`;console.warn(i,u),t.push(this.getFailureResult(i,{databaseName:e.name,storeName:""},"DatabaseUpgradeBlocked"))},blocking:async(o,a,u)=>{let i=`Database upgrade blocking. Current version: ${o}, Blocked version: ${a}, trying to close db.`;console.warn(i,u);try{this.getInstance(e.name)?.instance.close();let d={databaseName:e.name,storeName:""};t.push(this.getSuccessResult(i,void 0,d,"DatabaseUpgradeBlocking"))}catch(c){let d=`Could not close db, will try again. ${c}`;console.error(d),t.push(this.getFailureResult(d,{databaseName:e.name,storeName:""},"DatabaseUpgradeBlocking"))}}});r={name:e.name,instance:n,executingCursors:[]},this.instances.push(r)}}catch(n){return t.push(this.getFailureResult(`Could not open db ${n}`,{databaseName:e.name,storeName:""},"DatabaseOpenError")),t}try{let n=await this.verifySchema(r.instance,e);t.push(...n)}catch(n){t.push(this.getFailureResult(`Could not verify schema ${n}`,{databaseName:e.name,storeName:""},"SchemaVerificationError"))}return t.some(n=>!n.success)||t.push(this.getSuccessResult(`Database ${e.name} opened`,void 0,{databaseName:e.name,storeName:""},"DatabaseOpened")),t}async deleteDb(e){try{let t=this.getInstance(e);t?.instance.close(),await $(e),t&&this.instances.splice(this.instances.indexOf(t),1);let r=`The database ${e} has been deleted.`;return this.getSuccessResult(r,void 0,{databaseName:e,storeName:""},"DatabaseDeleted")}catch(t){return this.getFailureResult(`Error deleting database: ${t}`,{databaseName:e,storeName:""},"DatabaseDeleteError")}}async getDatabaseInfo(e){try{let t=this.getInstance(e).instance,r={name:t.name,version:t.version,storeNames:this.getStoreNames(t.objectStoreNames)};return this.getSuccessResult("Database information retrieved",r,{databaseName:t.name,storeName:""},"DatabaseInfo")}catch(t){return this.getFailureResult(`Error getting database information: ${t}`,{databaseName:e,storeName:""},"DatabaseInfoError")}}async addRecord(e){let t=e.data;try{let{tx:r,objectStore:n,idbKeyResult:o}=this.getStoreQuery(e,"readwrite");if(t=this.removePrimaryKeyPropertyIfAutoIncrement(n,t),!n.add)return this.getFailureResult("Add method not available on object store",e,"RecordQueryError");let a;if(!o.success&&e.useKey)return this.getFailureResult("Unable to update record, key not valid",e,"RecordQueryError");o.success&&e.useKey&&(a=o.result.data.value);let u=await n.add(t,a),i=await n.get(u);await r.done;let c=`Added new record with id ${u}`;return this.getSuccessResult(c,i,e,"Record")}catch(r){return this.getFailureResult(`Error adding record: ${r}`,e,"RecordQueryError")}}async updateRecord(e){try{let{tx:t,idbKeyResult:r,objectStore:n}=this.getStoreQuery(e,"readwrite");if(!n.put)return this.getFailureResult("Put method not available on object store",e,"RecordQueryError");let o;if(!r.success&&e.useKey)return this.getFailureResult("Unable to update record, key not valid",e,"RecordQueryError");r.success&&e.useKey&&(o=r.result.data.value);let a=await n.put(e.data,o),u=await n.get(a);await t.done;let i=`Updated record with id ${a}`;return this.getSuccessResult(i,u,e,"Record")}catch(t){return this.getFailureResult(`Error updating record: ${t}`,e,"RecordQueryError")}}async deleteRecord(e){try{let{tx:t,objectStore:r,idbKeyResult:n}=this.getStoreQuery(e,"readwrite");return r.delete?n.success?n.result.data.type==="NoQuery"?this.getFailureResult("Error deleting record: NoQuery is not a valid query",e,"RecordQueryError"):(await r.delete(n.result.data.value),await t.done,this.getSuccessResult(`Deleted records from store ${e.storeName}`,void 0,e,"RecordDeleted")):this.getFailureResult(`Error deleting record: ${n.message}`,e,"RecordQueryError"):this.getFailureResult("delete method not available on object store",e,"RecordQueryError")}catch(t){return this.getFailureResult(`Error deleting record: ${t}`,e,"RecordQueryError")}}async clearStore(e){try{let{tx:t,objectStore:r}=this.getTransaction(e,"readwrite");return r.clear?(await r.clear(),await t.done,this.getSuccessResult(`Store ${e.storeName} cleared`,void 0,e,"StoreCleared")):this.getFailureResult("Clear method not available on object store",e,"StoreQueryError")}catch(t){return this.getFailureResult(`Error clearing store ${e.storeName}: ${t}`,e,"StoreQueryError")}}async openCursor(e,t){try{let r=this.getQueryPath(e),{objectStore:n,tx:o,idbKeyResult:a,index:u}=this.getStoreQuery(e,"readonly");if(!a.success)return a;let i=this.getInstance(e.databaseName);if(this.getInstanceExecutingCursor(i,e))return this.getFailureResult("Another cursor is already open",e,"CursorFailure");let d=a.result.data.value,y=await(u??n).openCursor(d,t);return await o.done,y?.value?(i.executingCursors.push({initialQuery:e,cursorPosition:1,direction:t}),this.getSuccessResult(`Cursor result ${r}`,y.value,e,"CursorRecord")):this.getSuccessResult(`Cursor result ${r}`,void 0,e,"CursorClosed")}catch(r){return this.getFailureResult(`Error getting records ${r}`,e,"CursorFailure")}}async advanceCursor(e){try{let t=this.getQueryPath(e),r=this.getInstance(e.databaseName),n=this.getInstanceExecutingCursor(r,e);if(n){let{objectStore:o,tx:a,idbKeyResult:u,index:i}=this.getStoreQuery(n.initialQuery,"readonly");if(!u.success)return u;let c=u.result.data.value,y=await(await(i??o).openCursor(c,n.direction))?.advance(n.cursorPosition);return await a.done,!y||!y.value?(r.executingCursors.splice(r.executingCursors.indexOf(n),1),this.getSuccessResult(`No more records ${t}`,void 0,e,"CursorClosed")):(n.cursorPosition+=1,this.getSuccessResult(`Cursor record ${t}`,y.value,e,"CursorRecord"))}return this.getSuccessResult(`No cursor is open ${t}`,void 0,e,"CursorNotOpen")}catch(t){return this.getFailureResult(`Error getting records ${t}`,e,"CursorFailure")}}async closeCursor(e){try{let t=this.getInstance(e.databaseName),r=this.getInstanceExecutingCursor(t,e);return r?(t.executingCursors.splice(t.executingCursors.indexOf(r),1),this.getSuccessResult("",void 0,e,"CursorClosed")):this.getSuccessResult("No cursor is open",void 0,e,"CursorNotOpen")}catch(t){return this.getFailureResult(`Error closing cursor: ${t}`,e,"CursorFailure")}}async closeAllStoreCursors(e){try{let t=this.getInstance(e.databaseName);return t.executingCursors=t.executingCursors.filter(r=>r.initialQuery.databaseName!==e.databaseName&&r.initialQuery.storeName!==e.storeName),this.getSuccessResult("",void 0,e,"CursorNoMoreRecords")}catch(t){return this.getFailureResult(`Error closing cursor: ${t}`,e,"CursorFailure")}}async closeAllCursors(e){try{let t=this.getInstance(e.databaseName);return t.executingCursors=[],this.getSuccessResult("",void 0,{databaseName:e.databaseName,storeName:""},"CursorClosed")}catch(t){return this.getFailureResult(`Error closing cursor: ${t}`,{databaseName:e.databaseName,storeName:""},"CursorFailure")}}async iterateRecords(e,t){try{let r=this.getQueryPath(e),{objectStore:n,tx:o,idbKeyResult:a,index:u}=this.getStoreQuery(e,"readonly");if(!a.success)return a;let i=[],d=(u??n).iterate(a.result.data.value,t);for await(let h of d)i.push(h.value);return await o.done,this.getSuccessResult(`${i.length} records retrieved ${r}`,i,e,i.length>0?"Record":"RecordNotFound")}catch(r){return this.getFailureResult(`Error getting records ${r}`,e,"StoreQueryError")}}async getRecord(e){try{let t=this.getQueryPath(e),{objectStore:r,tx:n,idbKeyResult:o,index:a}=this.getStoreQuery(e,"readonly");if(!o.success)return o;if(o.result.data.type==="NoQuery")return this.getFailureResult("NoQuery is not a valid query",e,"RecordQueryError");let i=await(a??r).get(o.result.data.value);return await n.done,this.getSuccessResult(`${i?"1":"0"} record retrieved ${t}`,i,e,i?"Record":"RecordNotFound")}catch(t){return this.getFailureResult(`Error getting record: ${t}`,e,"StoreQueryError")}}async getAllRecords(e,t){try{let r=this.getQueryPath(e),{objectStore:n,tx:o,idbKeyResult:a,index:u}=this.getStoreQuery(e,"readonly");if(!a.success)return a;let c=await(u??n).getAll(a.result.data.value,t>0?t:void 0);return await o.done,this.getSuccessResult(`${c.length} records retrieved from ${r}`,c,e,c.length>0?"Record":"RecordNotFound")}catch(r){return this.getFailureResult(`Error getting records: ${r}`,e,"StoreQueryError")}}async getAllKeys(e,t){try{let r=this.getQueryPath(e),{objectStore:n,tx:o,idbKeyResult:a,index:u}=this.getStoreQuery(e,"readonly");if(!a.success)return a;let c=await(u??n).getAllKeys(a.result.data.value,t>0?t:void 0);return await o.done,this.getSuccessResult(`${c.length} keys retrieved from ${r}`,c,e,c.length>0?"Record":"RecordNotFound")}catch(r){return this.getFailureResult(`Error getting keys: ${r}`,e,"StoreQueryError")}}async getKey(e){try{let t=this.getQueryPath(e),{objectStore:r,tx:n,idbKeyResult:o,index:a}=this.getStoreQuery(e,"readonly");if(!o.success)return o;if(o.result.data.type==="NoQuery")return this.getFailureResult("NoQuery is not a valid query",e,"RecordQueryError");let i=await(a??r).getKey(o.result.data.value);return await n.done,this.getSuccessResult(`${i?"1":"0"} keys retrieved from ${t}`,i,e,i?"Record":"RecordNotFound")}catch(t){return this.getFailureResult(`Error getting keys: ${t}`,e,"StoreQueryError")}}getIDBKey(e){let t,r=e.queryValue;try{switch(r.queryType){case"BoundQuery":t={type:"KeyRange",value:IDBKeyRange.bound(r.lower,r.upper,r.lowerOpen,r.upperOpen)};break;case"LowerBoundQuery":t={type:"KeyRange",value:IDBKeyRange.lowerBound(r.lowerBound,r.lowerOpen)};break;case"UpperBoundQuery":t={type:"KeyRange",value:IDBKeyRange.upperBound(r.upperBound,r.upperOpen)};break;case"OnlyQuery":t={type:"KeyRange",value:IDBKeyRange.only(r.value)};break;case"ValidKeyQuery":t={type:"ValidKey",value:r.value};break;case"NoQuery":t={type:"NoQuery",value:void 0};break;default:return this.getFailureResult(`Invalid query type ${r.queryType}`,e,"IDBKeyFailure")}}catch(n){return this.getFailureResult(`Failed to create key ${n}`,e,"IDBKeyFailure")}return this.getSuccessResult("",t,e,"IDBKeyCreated")}getStoreQuery(e,t){let{tx:r,objectStore:n}=this.getTransaction(e,t),o=this.getIDBKey(e),a=e.indexName?n.index(e.indexName):void 0;return{objectStore:n,tx:r,idbKeyResult:o,index:a}}getTransaction(e,t){let n=this.getInstance(e.databaseName).instance.transaction(e.storeName,t),o=n.objectStore(e.storeName);return{tx:n,objectStore:o}}removePrimaryKeyPropertyIfAutoIncrement(e,t){return!e.autoIncrement||!e.keyPath||Array.isArray(e.keyPath)||Object.hasOwn(t,e.keyPath)&&delete t[e.keyPath],t}upgradeDatabase(e,t,r,n,o){let a=[];if(r<n)for(var u of t.stores){if(!e.objectStoreNames.contains(u.name)){a.push(...this.addNewStore(e,u,r,n));continue}let i=o.objectStore(u.name);for(let c of u.indexes)i.indexNames.contains(c.name)||a.push(this.createIndexForStore(c,i,r,n))}return a}async verifySchema(e,t){let r=[];if(t.stores)for(var n of t.stores){let o={databaseName:t.name,storeName:n.name};if(!e.objectStoreNames.contains(n.name)){r.push(this.getFailureResult(`Store ${n.name} not found in database`,o,"StoreNotFound"));continue}let u=e.transaction(n.name,"readonly").objectStore(n.name);for(let i of n.indexes){if(!u.indexNames.contains(i.name)){r.push(this.getFailureResult(`Index ${i.name} not found in store ${n.name}`,o,"IndexNotFound"));continue}let c=u.index(i.name);if(Array.isArray(c.keyPath))for(let d of c.keyPath)i.keyPath.includes(d)||r.push(this.getFailureResult(`Index ${i.name} keyPath does not match. Expected: ${i.keyPath}, Actual: ${c.keyPath}`,o,"IndexKeyPathMismatch"));else i.keyPath.includes(c.keyPath)||r.push(this.getFailureResult(`Index ${i.name} keyPath does not match. Expected: ${i.keyPath}, Actual: ${c.keyPath}`,o,"IndexKeyPathMismatch"))}}return r}addNewStore(e,t,r,n){let o=[],a=t.primaryKey;a||(a={name:"id",keyPath:["id"],auto:!0,multiEntry:!1,unique:!0,keepAsArrayOnSingleValue:!1});let u=a.keyPath.length==1?a.keyPath[0]:a.keyPath;try{let c=e.createObjectStore(t.name,{keyPath:u,autoIncrement:a.auto}),d={databaseName:e.name,storeName:t.name};o.push(this.getSuccessResult(`Store ${t.name} created inside ${e.name} as it was missing when upgrading from v${r} to v${n}`,void 0,d,"StoreCreated"));for(var i of t.indexes)o.push(this.createIndexForStore(i,c,r,n))}catch(c){o.push(this.getFailureResult(`Error creating store ${t.name}: ${c}`,{databaseName:e.name,storeName:t.name},"StoreCreationError"))}return o}createIndexForStore(e,t,r,n){let o=e.keyPath;if(e.keyPath.length===1&&!e.keepAsArrayOnSingleValue&&(o=e.keyPath[0]),e.multiEntry&&e.keyPath.length>1)return this.getFailureResult(`Index ${e.name} has multiEntry set to true but has multiple keyPaths. This is not supported.`,{databaseName:t.transaction.db.name,storeName:t.name},"MultiEntryIndexWithMultipleKeyPaths");e.multiEntry&&e.keyPath.length===1&&(o=e.keyPath[0]);try{t.createIndex(e.name,o,{unique:e.unique,multiEntry:e.multiEntry})}catch(u){return this.getFailureResult(`Error creating index ${e.name} for store ${t.name}: ${u}`,{databaseName:t.transaction.db.name,storeName:t.name},"IndexCreationError")}let a=`Index ${e.name} created inside ${t.name} as it was missing when upgrading from v${r} to v${n}`;return this.getSuccessResult(a,void 0,{databaseName:"",storeName:t.name},"IndexCreated")}getSuccessResult(e,t,r,n){let o={success:!0,result:{data:t,databaseName:r.databaseName,storeName:r.storeName},message:e,type:n};return this._sendNotifications&&this._dbManagerRef.invokeMethodAsync(F,o),o}getFailureResult(e,t,r){let n={success:!1,result:{data:void 0,databaseName:t.databaseName,storeName:t.storeName},message:e,type:r};return this._sendNotifications&&this._dbManagerRef.invokeMethodAsync(F,n),n}getInstance(e){return this.instances.find(t=>t.name.toLowerCase()===e.toLowerCase())}getInstanceExecutingCursor(e,t){return e.executingCursors.find(r=>r.initialQuery.databaseName===t.databaseName&&r.initialQuery.storeName===t.storeName&&r.initialQuery.indexName===t.indexName&&JSON.stringify(r.initialQuery.queryValue)===JSON.stringify(t.queryValue))}getQueryPath(e){return`${e.databaseName}->${e.storeName}${e.indexName?`->${e.indexName}`:""}`}getStoreNames(e){let t=[];for(let r of e)t.push(r);return t}};var N,U;function te(s){N||(N=new m(s),window.dbManager=N,U=s.dotNetReference,console.log("IndexedDbManager initialized"))}export{N as IDBManager,te as initIndexedDbManager};
//# sourceMappingURL=client.js.map
