{
  "version": 3,
  "sources": ["../node_modules/idb/build/index.js", "../client/indexedDbBlazor.ts", "../client/app.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "\uFEFFimport { IDBPObjectStore, IDBPDatabase, openDB, deleteDB, TypedDOMStringList, StoreNames, IDBPTransaction } from \"idb\";\r\nimport { IIndexedDBDatabase, IStoreSchema, DBInformation, IIndexSpec, IIndexedDBDatabaseInstance, IndexedDBCursorQuery, IndexedDBJSConfig } from \"./models/InteropInterfaces\";\r\nimport { DotNet } from \"@microsoft/dotnet-js-interop\";\r\nimport { IndexedDBActionResult, IndexedDBActionResultFailure, IndexedDBActionResultSuccess, IndexedDBActionResultType } from \"./models/actionResult\";\r\nimport { IndexedDBQueryType, IndexedDBQueryConvertion, IndexedDBQuery } from \"./models/queryValue\";\r\nimport { IndexedDBRecordAction, IndexedDBObjectBase } from \"./models/record\";\r\n// import { UPGRADE_CHANNEL } from \"./utils\";\r\nconst RAISE_EVENT_METHOD = \"RaiseNotificationFromJS\";\r\n//https://web.dev/articles/indexeddb\r\nexport class IndexedDbManager {\r\n\r\n    private instances: IIndexedDBDatabaseInstance[] = [];\r\n    private _dbManagerRef: DotNet.DotNetObject;\r\n    private _sendNotifications = false;\r\n\r\n    constructor(instanceConfig: IndexedDBJSConfig) {\r\n        this._dbManagerRef = instanceConfig.dotNetReference;\r\n        this._sendNotifications = instanceConfig.sendNotificationsFromJS;\r\n    }\r\n\r\n\r\n    public async openDb(indexedDatabase: IIndexedDBDatabase) {\r\n        const dbOpenOutcomes: IndexedDBActionResult<any>[] = [];\r\n        let dbInstance = this.getInstance(indexedDatabase.name);\r\n        try {\r\n            if (!dbInstance || dbInstance.instance.version < indexedDatabase.version) {\r\n                if (dbInstance) {\r\n                    dbInstance.instance.close();\r\n                    this.instances.splice(this.instances.indexOf(dbInstance), 1);\r\n                }\r\n\r\n                const instance = await openDB(indexedDatabase.name, indexedDatabase.version, {\r\n                    upgrade: async (database, oldVersion, newVersion, transaction) => {\r\n\r\n                        const outcomes = this.upgradeDatabase(database, indexedDatabase, oldVersion, newVersion!, transaction);\r\n                        await transaction.done;\r\n                        dbOpenOutcomes.push(...outcomes);\r\n                    },\r\n                    blocked: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocked. Current version: ${currentVersion}, Blocked version: ${blockedVersion}`;\r\n                        console.warn(message, event);\r\n                        dbOpenOutcomes.push(\r\n                            this.getFailureResult(message, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseUpgradeBlocked\"));\r\n                    },\r\n                    blocking: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocking. Current version: ${currentVersion}, Blocked version: ${blockedVersion}, trying to close db.`;\r\n                        console.warn(message, event);\r\n                        try {\r\n                            let blockingInstance = this.getInstance(indexedDatabase.name);;\r\n                            blockingInstance?.instance.close();\r\n                            const baseInfo: IndexedDBObjectBase = { databaseName: indexedDatabase.name, storeName: \"\" };\r\n\r\n                            dbOpenOutcomes.push(\r\n                                this.getSuccessResult(message, undefined, baseInfo, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                        catch (e) {\r\n                            const message = `Could not close db, will try again. ${e}`;\r\n                            console.error(message);\r\n                            dbOpenOutcomes.push(\r\n                                this.getFailureResult(message, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n                dbInstance = { name: indexedDatabase.name, instance, executingCursors: [] };\r\n                this.instances.push(dbInstance);\r\n            }\r\n        } catch (e) {\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(`Could not open db ${e}`, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseOpenError\")\r\n            );\r\n            return dbOpenOutcomes;\r\n        }\r\n        try {\r\n            const result = await this.verifySchema(dbInstance.instance, indexedDatabase);\r\n            dbOpenOutcomes.push(...result);\r\n\r\n        }\r\n        catch (e) {\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(`Could not verify schema ${e}`, { databaseName: indexedDatabase.name, storeName: \"\" }, \"SchemaVerificationError\")\r\n            );\r\n        }\r\n        if (!dbOpenOutcomes.some(o => !o.success)) {\r\n            dbOpenOutcomes.push(this.getSuccessResult(`Database ${indexedDatabase.name} opened`, undefined, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseOpened\"));\r\n        }\r\n        return dbOpenOutcomes;\r\n    }\r\n\r\n    public async deleteDb(databaseName: string) {\r\n        try {\r\n            const db = this.getInstance(databaseName);\r\n            db?.instance.close();\r\n\r\n            await deleteDB(databaseName);\r\n            if (db) {\r\n                this.instances.splice(this.instances.indexOf(db), 1);\r\n            }\r\n            const msg = `The database ${databaseName} has been deleted.`;\r\n            return this.getSuccessResult(msg, undefined, { databaseName, storeName: \"\" }, \"DatabaseDeleted\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting database: ${e}`, { databaseName, storeName: \"\" }, \"DatabaseDeleteError\");\r\n        }\r\n    }\r\n\r\n    public async getDatabaseInfo(databaseName: string) {\r\n        try {\r\n            const instance = this.getInstance(databaseName)!.instance;\r\n            const dbInfo: DBInformation = {\r\n                name: instance.name,\r\n                version: instance.version,\r\n                storeNames: this.getStoreNames(instance.objectStoreNames)\r\n            };\r\n\r\n            return this.getSuccessResult(\"Database information retrieved\", dbInfo, { databaseName: instance.name, storeName: \"\" }, \"DatabaseInfo\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting database information: ${e}`, { databaseName, storeName: \"\" }, \"DatabaseInfoError\");\r\n        }\r\n    }\r\n\r\n    //#region CRUD\r\n    public async addRecord(record: IndexedDBRecordAction) {\r\n        let itemToSave = record.data;\r\n        try {\r\n            const { tx, objectStore, idbKeyResult } = this.getStoreQuery(record, \"readwrite\");\r\n            itemToSave = this.removePrimaryKeyPropertyIfAutoIncrement(objectStore, itemToSave);\r\n            if (!objectStore.add) {\r\n                return this.getFailureResult(\"Add method not available on object store\", record, \"RecordQueryError\");\r\n            }\r\n            let key: IDBValidKey | IDBKeyRange | undefined = undefined;\r\n            if (!idbKeyResult.success && record.useKey) {\r\n                return this.getFailureResult(\"Unable to update record, key not valid\", record, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.success && record.useKey) {\r\n                key = idbKeyResult.result.data.value;\r\n            }\r\n\r\n            const result = await objectStore.add(itemToSave, key);\r\n            const dbResult = await objectStore.get(result);\r\n            await tx.done;\r\n            const msg = `Added new record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult, record, \"Record\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error adding record: ${e}`, record, \"RecordQueryError\");\r\n        }\r\n\r\n    }\r\n\r\n    public async updateRecord(record: IndexedDBRecordAction) {\r\n        try {\r\n            const { tx, idbKeyResult, objectStore } = this.getStoreQuery(record, \"readwrite\");\r\n            if (!objectStore.put) {\r\n                return this.getFailureResult(\"Put method not available on object store\", record, \"RecordQueryError\");\r\n            }\r\n            let key: IDBValidKey | IDBKeyRange | undefined = undefined;\r\n            if (!idbKeyResult.success && record.useKey) {\r\n                return this.getFailureResult(\"Unable to update record, key not valid\", record, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.success && record.useKey) {\r\n                key = idbKeyResult.result.data.value;\r\n            }\r\n\r\n            const result = await objectStore.put(record.data, key);\r\n            const dbResult = await objectStore.get(result);\r\n            await tx.done;\r\n            const msg = `Updated record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult, record, \"Record\");\r\n\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error updating record: ${e}`, record, \"RecordQueryError\");\r\n        }\r\n    }\r\n\r\n    public async deleteRecord(query: IndexedDBQuery) {\r\n        try {\r\n            const { tx, objectStore, idbKeyResult } = this.getStoreQuery(query, \"readwrite\");\r\n            if (!objectStore.delete) {\r\n                return this.getFailureResult(\"delete method not available on object store\", query, \"RecordQueryError\");\r\n            }\r\n            if (!idbKeyResult.success) {\r\n                return this.getFailureResult(`Error deleting record: ${idbKeyResult.message}`, query, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`Error deleting record: NoQuery is not a valid query`, query, \"RecordQueryError\");\r\n            }\r\n            await objectStore.delete(idbKeyResult.result.data.value);\r\n            await tx.done;\r\n            return this.getSuccessResult(`Deleted records from store ${query.storeName}`, undefined, query, \"RecordDeleted\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting record: ${e}`, query, \"RecordQueryError\");\r\n        }\r\n    }\r\n\r\n    public async clearStore(record: IndexedDBObjectBase) {\r\n\r\n        try {\r\n            const { tx, objectStore } = this.getTransaction(record, \"readwrite\");\r\n            if (!objectStore.clear) {\r\n                return this.getFailureResult(\"Clear method not available on object store\", record, \"StoreQueryError\");\r\n            }\r\n            await objectStore.clear();\r\n            await tx.done;\r\n            return this.getSuccessResult(`Store ${record.storeName} cleared`, undefined, record, \"StoreCleared\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error clearing store ${record.storeName}: ${e}`, record, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region StoreRecordQueries\r\n\r\n    public async openCursor(searchData: IndexedDBQuery, direction?: IDBCursorDirection) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n            if (executingCursor) {\r\n                return this.getFailureResult(`Another cursor is already open`, searchData, \"CursorFailure\");\r\n            }\r\n            const query = idbKeyResult.result.data.value;\r\n            const queryObject = index ?? objectStore;\r\n            const rs = await queryObject.openCursor(query, direction);\r\n            await tx.done;\r\n            if (rs?.value) {\r\n                instance.executingCursors.push({ initialQuery: searchData, cursorPosition: 1, direction });\r\n                return this.getSuccessResult(`Cursor result ${queryPath}`, rs.value, searchData, \"CursorRecord\");\r\n\r\n            }\r\n            return this.getSuccessResult(`Cursor result ${queryPath}`, undefined, searchData, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async advanceCursor(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n            if (executingCursor) {\r\n                const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(executingCursor.initialQuery, \"readonly\");\r\n                if (!idbKeyResult.success) {\r\n                    return idbKeyResult\r\n                }\r\n                const query = idbKeyResult.result.data.value;\r\n                const queryObject = index ?? objectStore;\r\n                const rs = await queryObject.openCursor(query, executingCursor.direction);\r\n                const next = await rs?.advance(executingCursor.cursorPosition);\r\n                await tx.done;\r\n                if (!next || !next.value) {\r\n                    instance.executingCursors.splice(instance.executingCursors.indexOf(executingCursor), 1);\r\n                    return this.getSuccessResult(`No more records ${queryPath}`, undefined, searchData, \"CursorClosed\");\r\n                }\r\n                executingCursor.cursorPosition += 1;\r\n                return this.getSuccessResult(`Cursor record ${queryPath}`, next.value, searchData, \"CursorRecord\");\r\n\r\n            }\r\n            return this.getSuccessResult(`No cursor is open ${queryPath}`, undefined, searchData, \"CursorNotOpen\");\r\n\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n    public async closeCursor(searchData: IndexedDBQuery) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n\r\n            if (!executingCursor) {\r\n                return this.getSuccessResult(`No cursor is open`, undefined, searchData, \"CursorNotOpen\");\r\n            }\r\n            instance.executingCursors.splice(instance.executingCursors.indexOf(executingCursor), 1);\r\n            return this.getSuccessResult(``, undefined, searchData, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async closeAllStoreCursors(searchData: IndexedDBObjectBase) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            instance.executingCursors = instance.executingCursors.filter(c =>\r\n                c.initialQuery.databaseName !== searchData.databaseName &&\r\n                c.initialQuery.storeName !== searchData.storeName\r\n            );\r\n            return this.getSuccessResult(``, undefined, searchData, \"CursorNoMoreRecords\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n    public async closeAllCursors(searchData: IndexedDBObjectBase) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            instance.executingCursors = [];\r\n            return this.getSuccessResult(``, undefined, { databaseName: searchData.databaseName, storeName: \"\" }, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, { databaseName: searchData.databaseName, storeName: \"\" }, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async iterateRecords(searchData: IndexedDBQuery, direction?: IDBCursorDirection) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results: any[] = [];\r\n            const queryObject = index ?? objectStore;\r\n            const recordIterator = queryObject.iterate(idbKeyResult.result.data.value, direction);\r\n            for await (const cursor of recordIterator) {\r\n                results.push(cursor.value);\r\n            }\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} records retrieved ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getRecord(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`NoQuery is not a valid query`, searchData, \"RecordQueryError\");\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.get(idbKeyResult.result.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results ? \"1\" : \"0\"} record retrieved ${queryPath}`, results, searchData, results ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting record: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getAllRecords(searchData: IndexedDBQuery, count: number) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getAll(idbKeyResult.result.data.value, count > 0 ? count : undefined)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} records retrieved from ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getAllKeys(searchData: IndexedDBQuery, count: number) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getAllKeys(idbKeyResult.result.data.value, count > 0 ? count : undefined)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} keys retrieved from ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting keys: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getKey(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`NoQuery is not a valid query`, searchData, \"RecordQueryError\");\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getKey(idbKeyResult.result.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results ? \"1\" : \"0\"} keys retrieved from ${queryPath}`, results, searchData, results ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting keys: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n    //#endregion\r\n\r\n    private getIDBKey(incommingQuery: IndexedDBQuery) {\r\n        let result: IndexedDBQueryConvertion | undefined;\r\n        const query = incommingQuery.queryValue;\r\n        try {\r\n            switch (query.queryType) {\r\n                case \"BoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.bound(query.lower, query.upper, query.lowerOpen, query.upperOpen) };\r\n\r\n                    break;\r\n                case \"LowerBoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.lowerBound(query.lowerBound, query.lowerOpen) };\r\n\r\n                    break;\r\n                case \"UpperBoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.upperBound(query.upperBound, query.upperOpen) };\r\n\r\n                    break;\r\n                case \"OnlyQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.only(query.value) };\r\n                    break;\r\n                case \"ValidKeyQuery\":\r\n                    result = { type: \"ValidKey\", value: query.value };\r\n                    break;\r\n                case \"NoQuery\":\r\n                    result = { type: \"NoQuery\", value: undefined };\r\n                    break;\r\n                default:\r\n                    return this.getFailureResult(`Invalid query type ${(query as any).queryType}`, incommingQuery, \"IDBKeyFailure\");\r\n            }\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Failed to create key ${e}`, incommingQuery, \"IDBKeyFailure\");\r\n        }\r\n        return this.getSuccessResult(\"\", result, incommingQuery, \"IDBKeyCreated\");\r\n    }\r\n\r\n    private getStoreQuery(searchData: IndexedDBQuery, transactionMode: IDBTransactionMode) {\r\n        const { tx, objectStore } = this.getTransaction(searchData, transactionMode);\r\n        const idbKeyResult = this.getIDBKey(searchData);\r\n        const index = searchData.indexName ? objectStore.index(searchData.indexName) : undefined;\r\n        return { objectStore, tx, idbKeyResult, index };\r\n    }\r\n\r\n    private getTransaction(searchData: IndexedDBObjectBase, mode: IDBTransactionMode) {\r\n        const db = this.getInstance(searchData.databaseName);\r\n        const tx = db!.instance.transaction(searchData.storeName, mode);\r\n        const objectStore = tx.objectStore(searchData.storeName);\r\n        return { tx, objectStore };\r\n    }\r\n\r\n    private removePrimaryKeyPropertyIfAutoIncrement(objectStore: IDBPObjectStore<unknown, [string], string, \"readonly\" | \"readwrite\" | \"versionchange\">, data: any) {\r\n        if (!objectStore.autoIncrement || !objectStore.keyPath) {\r\n            return data;\r\n        }\r\n\r\n        if (!Array.isArray(objectStore.keyPath)) {\r\n            if (Object.hasOwn(data, objectStore.keyPath)) {\r\n                delete data[objectStore.keyPath];\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    private upgradeDatabase(upgradeDB: IDBPDatabase, dbStore: IIndexedDBDatabase, oldVersion: number, newVersion: number, transaction: IDBPTransaction<any, StoreNames<any>[], \"versionchange\">) {\r\n        const outcomes: IndexedDBActionResult<any>[] = [];\r\n        if (oldVersion < newVersion) {\r\n            //might not be needed\r\n            // for (const table of upgradeDB.objectStoreNames) {\r\n            //     if (!dbStore.stores.find(s => s.name === table)) {\r\n            //         upgradeDB.deleteObjectStore(table);\r\n            //         const message = `Store ${table} deleted as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n            //         outcomes.push(\r\n            //             this.getSuccessResult(message, undefined, \"TableDeleted\"));\r\n            //     }\r\n            // }\r\n\r\n            for (var store of dbStore.stores) {\r\n\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    outcomes.push(...this.addNewStore(upgradeDB, store, oldVersion, newVersion));\r\n                    continue;\r\n                }\r\n                const table = transaction.objectStore(store.name);\r\n                for (const indexSpec of store.indexes) {\r\n                    if (table.indexNames.contains(indexSpec.name)) {\r\n                        continue;\r\n                    }\r\n                    outcomes.push(this.createIndexForStore(indexSpec, table, oldVersion, newVersion));\r\n                }\r\n                //might not be needed\r\n                // for (const dbIndexName of table.indexNames) {\r\n                //     const dbIdxFound = store.indexes.find(i => i.name === String(dbIndexName));\r\n                //     if(!dbIdxFound){\r\n                //         table.deleteIndex(String(dbIndexName));\r\n                //         const message = `Index ${String(dbIndexName)} deleted inside ${store.name} as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n                //         outcomes.push(this.getSuccessResult(message, undefined, \"IndexDeleted\"));\r\n                //     }\r\n                // }\r\n            }\r\n\r\n        }\r\n        return outcomes;\r\n    }\r\n\r\n    private async verifySchema(upgradeDB: IDBPDatabase, database: IIndexedDBDatabase) {\r\n        const result: IndexedDBActionResult<undefined>[] = [];\r\n        if (database.stores) {\r\n            for (var store of database.stores) {\r\n                const processingObject = { databaseName: database.name, storeName: store.name };\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    result.push(\r\n                        this.getFailureResult(`Store ${store.name} not found in database`, processingObject, \"StoreNotFound\"));\r\n                    continue;\r\n                }\r\n\r\n                const tx = upgradeDB.transaction(store.name, \"readonly\");\r\n                const table = tx.objectStore(store.name);\r\n                for (const appIndex of store.indexes) {\r\n                    if (!table.indexNames.contains(appIndex.name)) {\r\n                        result.push(\r\n                            this.getFailureResult(`Index ${appIndex.name} not found in store ${store.name}`, processingObject, \"IndexNotFound\"));\r\n                        continue;\r\n                    }\r\n                    const idx = table.index(appIndex.name);\r\n                    if (Array.isArray(idx.keyPath)) {\r\n                        for (const idxKey of idx.keyPath) {\r\n                            if (!appIndex.keyPath.includes(idxKey)) {\r\n                                result.push(\r\n                                    this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, processingObject, \"IndexKeyPathMismatch\"));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!appIndex.keyPath.includes(idx.keyPath)) {\r\n                            result.push(\r\n                                this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, processingObject, \"IndexKeyPathMismatch\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private addNewStore(upgradeDB: IDBPDatabase, store: IStoreSchema, oldVersion: number, newVersion: number) {\r\n        const storeOutcomes: IndexedDBActionResult<any>[] = []\r\n        let primaryKey = store.primaryKey;\r\n\r\n        if (!primaryKey) {\r\n            primaryKey = { name: \"id\", keyPath: [\"id\"], auto: true, multiEntry: false, unique: true, keepAsArrayOnSingleValue: false };\r\n        }\r\n        const primaryKeyPath = primaryKey.keyPath.length == 1 ? primaryKey.keyPath[0] : primaryKey.keyPath;\r\n\r\n        try {\r\n\r\n            const newStore = upgradeDB.createObjectStore(store.name, { keyPath: primaryKeyPath, autoIncrement: primaryKey.auto });\r\n            const baseInfo: IndexedDBObjectBase = { databaseName: upgradeDB.name, storeName: store.name };\r\n            storeOutcomes.push(this.getSuccessResult(`Store ${store.name} created inside ${upgradeDB.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`, undefined, baseInfo, \"StoreCreated\"));\r\n            for (var index of store.indexes) {\r\n                storeOutcomes.push(this.createIndexForStore(index, newStore, oldVersion, newVersion));\r\n            }\r\n        }\r\n        catch (e) {\r\n            storeOutcomes.push(this.getFailureResult(`Error creating store ${store.name}: ${e}`, { databaseName: upgradeDB.name, storeName: store.name }, \"StoreCreationError\"));\r\n        }\r\n        return storeOutcomes;\r\n    }\r\n\r\n    private createIndexForStore(index: IIndexSpec, newStore: IDBPObjectStore<unknown, string[], string, \"versionchange\">, oldVersion: number, newVersion: number) {\r\n        let keyPath: string | string[] = index.keyPath;\r\n        if (index.keyPath.length === 1 && !index.keepAsArrayOnSingleValue) {\r\n            keyPath = index.keyPath[0];\r\n        }\r\n\r\n        if (index.multiEntry && index.keyPath.length > 1) {\r\n            return this.getFailureResult(`Index ${index.name} has multiEntry set to true but has multiple keyPaths. This is not supported.`, { databaseName: newStore.transaction.db.name, storeName: newStore.name }, \"MultiEntryIndexWithMultipleKeyPaths\");\r\n        }\r\n        if (index.multiEntry && index.keyPath.length === 1) {\r\n            //TODO: handle multiEntry indexes with multiple keyPaths\r\n            keyPath = index.keyPath[0];\r\n        }\r\n        try {\r\n            newStore.createIndex(index.name, keyPath, { unique: index.unique, multiEntry: index.multiEntry });\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error creating index ${index.name} for store ${newStore.name}: ${e}`, { databaseName: newStore.transaction.db.name, storeName: newStore.name }, \"IndexCreationError\");\r\n        }\r\n        const message = `Index ${index.name} created inside ${newStore.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`;\r\n        return this.getSuccessResult(message, undefined, { databaseName: \"\", storeName: newStore.name }, \"IndexCreated\");\r\n    }\r\n\r\n    private getSuccessResult<T extends any>(successMessage: string, data: T, requestBase: IndexedDBObjectBase, type: IndexedDBActionResultType): IndexedDBActionResultSuccess<T> {\r\n        const result: IndexedDBActionResultSuccess<T> = {\r\n            success: true,\r\n            result: {\r\n                data,\r\n                databaseName: requestBase.databaseName,\r\n                storeName: requestBase.storeName\r\n            },\r\n            message: successMessage,\r\n            type\r\n        }\r\n        if (this._sendNotifications) {\r\n            this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, result)\r\n            if (DEBUG) {\r\n                console.log(result);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    private getFailureResult(errorMessage: string, requestBase: IndexedDBObjectBase, type: IndexedDBActionResultType): IndexedDBActionResultFailure {\r\n        const result: IndexedDBActionResultFailure = {\r\n            success: false,\r\n            result: {\r\n                data: undefined,\r\n                databaseName: requestBase.databaseName,\r\n                storeName: requestBase.storeName\r\n            },\r\n            message: errorMessage,\r\n            type\r\n        }\r\n        if (this._sendNotifications) {\r\n            this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, result)\r\n            if (DEBUG) {\r\n                console.log(result);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private getInstance(dbName: string) {\r\n        return this.instances.find(i => i.name.toLowerCase() === dbName.toLowerCase())\r\n    }\r\n\r\n    private getInstanceExecutingCursor(instance: IIndexedDBDatabaseInstance, searchData: IndexedDBQuery) {\r\n        return instance.executingCursors.find(c =>\r\n            c.initialQuery.databaseName === searchData.databaseName &&\r\n            c.initialQuery.storeName === searchData.storeName &&\r\n            c.initialQuery.indexName === searchData.indexName &&\r\n            //Might not be the best idea or needed at all\r\n            JSON.stringify(c.initialQuery.queryValue) === JSON.stringify(searchData.queryValue)\r\n        );\r\n    }\r\n\r\n    private getQueryPath(searchData: IndexedDBQuery) {\r\n        return `${searchData.databaseName}->${searchData.storeName}${searchData.indexName ? `->${searchData.indexName}` : ``}`;\r\n    }\r\n\r\n    private getStoreNames(list: TypedDOMStringList<StoreNames<any>>) {\r\n        const names: string[] = [];\r\n        for (const storeName of list) {\r\n            names.push(storeName);\r\n        }\r\n        return names;\r\n    }\r\n\r\n    // private async ensureDatabaseOpen(dbName: string) {\r\n    //     let dbInstance = this.instances.find(i => i.name === dbName);\r\n    //     if (!dbInstance) {\r\n    //         dbInstance = {\r\n    //             name: dbName,\r\n    //             instance: await openDB(dbName)\r\n    //         }\r\n    //         this.instances.push(dbInstance);\r\n    //     }\r\n    //     return dbInstance.instance;\r\n    // }\r\n\r\n}", "\uFEFFimport { IndexedDbManager } from './indexedDbBlazor';\r\nimport { type DotNet } from \"@microsoft/dotnet-js-interop\";\r\nimport { IndexedDBJSConfig } from './models/InteropInterfaces';\r\n\r\nexport let IDBManager: IndexedDbManager | undefined;\r\nlet _dbManagerRef: DotNet.DotNetObject | undefined;\r\nexport function initIndexedDbManager(config: IndexedDBJSConfig) {\r\n    if (IDBManager) { return; }\r\n    IDBManager = new IndexedDbManager(config);\r\n    (window as any).dbManager = IDBManager;\r\n    _dbManagerRef = config.dotNetReference;\r\n    console.log(\"IndexedDbManager initialized\");\r\n}"],
  "mappings": "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",
  "names": ["instanceOfAny", "object", "constructors", "c", "idbProxyableTypes", "cursorAdvanceMethods", "getIdbProxyableTypes", "getCursorAdvanceMethods", "transactionDoneMap", "transformCache", "reverseTransformCache", "promisifyRequest", "request", "promise", "resolve", "reject", "unlisten", "success", "error", "wrap", "cacheDonePromiseForTransaction", "tx", "done", "complete", "idbProxyTraps", "target", "prop", "receiver", "value", "replaceTraps", "callback", "wrapFunction", "func", "args", "unwrap", "transformCachableValue", "newValue", "openDB", "name", "version", "blocked", "upgrade", "blocking", "terminated", "openPromise", "event", "db", "deleteDB", "readMethods", "writeMethods", "cachedMethods", "getMethod", "targetFuncName", "useIndex", "isWrite", "method", "storeName", "oldTraps", "advanceMethodProps", "methodMap", "advanceResults", "ittrProxiedCursorToOriginalProxy", "cursorIteratorTraps", "cachedFunc", "iterate", "cursor", "proxiedCursor", "isIteratorProp", "RAISE_EVENT_METHOD", "IndexedDbManager", "instanceConfig", "indexedDatabase", "dbOpenOutcomes", "dbInstance", "instance", "openDB", "database", "oldVersion", "newVersion", "transaction", "outcomes", "currentVersion", "blockedVersion", "event", "message", "baseInfo", "e", "result", "o", "databaseName", "db", "deleteDB", "msg", "dbInfo", "record", "itemToSave", "tx", "objectStore", "idbKeyResult", "key", "dbResult", "query", "searchData", "direction", "queryPath", "index", "rs", "executingCursor", "next", "c", "results", "recordIterator", "cursor", "count", "incommingQuery", "transactionMode", "mode", "data", "upgradeDB", "dbStore", "store", "table", "indexSpec", "processingObject", "appIndex", "idx", "idxKey", "storeOutcomes", "primaryKey", "primaryKeyPath", "newStore", "keyPath", "successMessage", "requestBase", "type", "errorMessage", "dbName", "i", "list", "names", "storeName", "IDBManager", "_dbManagerRef", "initIndexedDbManager", "config", "IndexedDbManager"]
}
