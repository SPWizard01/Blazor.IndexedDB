{
  "version": 3,
  "sources": ["../node_modules/idb/build/index.js", "../client/indexedDbBlazor.ts", "../client/app.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "\uFEFFimport { IDBPObjectStore, IDBPDatabase, openDB, deleteDB, TypedDOMStringList, StoreNames, IDBPTransaction } from \"idb\";\r\nimport { IDbStore, IndexedDBQuerySearch, IStoreRecord, IStoreSchema, DBInformation, IIndexSpec, IndexedDBSearch } from \"./models/InteropInterfaces\";\r\nimport { DotNet } from \"@microsoft/dotnet-js-interop\";\r\nimport { UpgradeOutcome } from \"./models/upgradeOutcome\";\r\nimport { IndexedDBActionResult, IndexedDBActionResultFailure, IndexedDBActionResultSuccess } from \"./models/actionResult\";\r\nimport { IndexedDBQuery, IndexedDBQueryConvertion } from \"./models/queryValue\";\r\n// import { UPGRADE_CHANNEL } from \"./utils\";\r\nconst RAISE_EVENT_METHOD = \"RaiseNotificationFromJS\";\r\n//https://web.dev/articles/indexeddb\r\nexport class IndexedDbManager {\r\n\r\n    private dbInstance: IDBPDatabase | undefined;\r\n    private _dbManagerRef: DotNet.DotNetObject;\r\n    // private upgradeChannel: BroadcastChannel; \r\n\r\n    constructor(dbManagerRef: DotNet.DotNetObject) {\r\n        this._dbManagerRef = dbManagerRef;\r\n    }\r\n\r\n\r\n    public async openDb(data: IDbStore) {\r\n        const dbStore = data;\r\n        const dbOpenOutcomes: IndexedDBActionResult<any>[] = [];\r\n        try {\r\n            if (!this.dbInstance || this.dbInstance.version < dbStore.version) {\r\n                if (this.dbInstance) {\r\n                    this.dbInstance.close();\r\n                }\r\n                this.dbInstance = await openDB(dbStore.dbName, dbStore.version, {\r\n                    upgrade: async (database, oldVersion, newVersion, transaction) => {\r\n\r\n                        const outcomes = this.upgradeDatabase(database, dbStore, oldVersion, newVersion!, transaction);\r\n                        await transaction.done;\r\n                        dbOpenOutcomes.push(...outcomes);\r\n                    },\r\n                    blocked: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocked. Current version: ${currentVersion}, Blocked version: ${blockedVersion}`;\r\n                        console.warn(message, event);\r\n                        dbOpenOutcomes.push(\r\n                            this.getFailureResult(message, \"DatabaseUpgradeBlocked\"));\r\n                    },\r\n                    blocking: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocking. Current version: ${currentVersion}, Blocked version: ${blockedVersion}, trying to close db.`;\r\n                        console.warn(message, event);\r\n                        try {\r\n                            this.dbInstance!.close();\r\n                            dbOpenOutcomes.push(\r\n                                this.getSuccessResult(message, undefined, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                        catch (e) {\r\n                            const message = `Could not close db, will try again. ${e}`;\r\n                            console.error(message);\r\n                            dbOpenOutcomes.push(\r\n                                this.getFailureResult(message, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        } catch (e) {\r\n            const msg = `Could not open db ${e}`;\r\n            console.error(msg);\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(msg, \"DatabaseOpenError\")\r\n            );\r\n            return dbOpenOutcomes;\r\n        }\r\n        try {\r\n            const result = await this.verifySchema(this.dbInstance, dbStore);\r\n            dbOpenOutcomes.push(...result);\r\n\r\n        }\r\n        catch (e) {\r\n            const msg = `Could not verify schema ${e}`;\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(msg, \"SchemaVerificationError\")\r\n            );\r\n        }\r\n\r\n        return dbOpenOutcomes;\r\n    }\r\n\r\n    private getStoreNames(list: TypedDOMStringList<StoreNames<any>>) {\r\n        const names: string[] = [];\r\n        for (const storeName of list) {\r\n            names.push(storeName);\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public async getDbInfo(dbName: string) {\r\n        try {\r\n\r\n            await this.ensureDatabaseOpen(dbName);\r\n            const dbInfo: DBInformation = {\r\n                name: this.dbInstance!.name,\r\n                version: this.dbInstance!.version,\r\n                storeNames: this.getStoreNames(this.dbInstance!.objectStoreNames)\r\n            };\r\n\r\n            return this.getSuccessResult(\"Database information retrieved\", dbInfo);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting database information: ${e}`);\r\n        }\r\n    }\r\n\r\n\r\n    public async deleteDb(dbName: string) {\r\n        try {\r\n\r\n            this.dbInstance?.close();\r\n\r\n            await deleteDB(dbName);\r\n\r\n            this.dbInstance = undefined;\r\n            const msg = `The database ${dbName} has been deleted.`;\r\n            return this.getSuccessResult(msg, undefined);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting database: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async addRecord(record: IStoreRecord) {\r\n        const stName = record.storeName;\r\n        let itemToSave = record.data;\r\n\r\n\r\n        try {\r\n            const tx = this.getTransaction(stName, \"readwrite\");\r\n            const objectStore = tx.objectStore(stName);\r\n\r\n            itemToSave = this.removePrimaryKeyPropertyIfAutoIncrement(objectStore, itemToSave);\r\n            if (!objectStore.add) {\r\n                return this.getFailureResult(\"Add method not available on object store\");\r\n            }\r\n            console.log(itemToSave)\r\n            const result = await objectStore.add(itemToSave);\r\n            const dbResult = await objectStore.get(result!);\r\n            await tx.done;\r\n            const msg = `Added new record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error adding record: ${e}`);\r\n        }\r\n\r\n    }\r\n\r\n    public async updateRecord(record: IStoreRecord) {\r\n        const stName = record.storeName;\r\n        try {\r\n            const tx = this.getTransaction(stName, \"readwrite\");\r\n            const objectStore = tx.objectStore(stName);\r\n            if (!objectStore.put) {\r\n                return this.getFailureResult(\"Put method not available on object store\");\r\n            }\r\n            const result = await objectStore.put(record.data, record.key);\r\n            const dbResult = await objectStore.get(result);\r\n            await tx.done;\r\n            const msg = `Updated record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult);\r\n\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error updating record: ${e}`);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public async deleteRecord(record: IStoreRecord): Promise<IndexedDBActionResult<any>> {\r\n        if (!record.key) {\r\n            return this.getFailureResult(\"Record key is required to delete a record\");\r\n        }\r\n        const stName = record.storeName;\r\n\r\n        try {\r\n            const tx = this.getTransaction(stName, \"readwrite\");\r\n            const objectStore = tx.objectStore(stName);\r\n            if (!objectStore.delete) {\r\n                return this.getFailureResult(\"delete method not available on object store\");\r\n            }\r\n            await objectStore.delete(record.key);\r\n            await tx.done;\r\n            return this.getSuccessResult(`Deleted record with key ${record.key} from store ${stName}`, undefined);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting record: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async deleteRecordByKey(storename: string, id: any): Promise<IndexedDBActionResult<any>> {\r\n\r\n        try {\r\n            const tx = this.getTransaction(storename, \"readwrite\");\r\n            const objectStore = tx.objectStore(storename);\r\n            if (!objectStore.delete) {\r\n                return this.getFailureResult(\"delete method not available on object store\");\r\n            }\r\n            await objectStore.delete(id);\r\n            return this.getSuccessResult(`Deleted record with key ${id} from store ${storename}`, undefined);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting record: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async clearStore(storeName: string) {\r\n\r\n        try {\r\n            const tx = this.getTransaction(storeName, \"readwrite\");\r\n            await tx.objectStore(storeName).clear?.();\r\n            await tx.done;\r\n            return this.getSuccessResult(`Store ${storeName} cleared`, undefined);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error clearing store ${storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    //#region IndexQueries\r\n    public async iterateRecordsByIndex(searchData: IndexedDBQuerySearch, direction?: IDBCursorDirection) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results: any[] = [];\r\n            const recordIterator = index.iterate(idbKeyResult.data.value, direction);\r\n            for await (const cursor of recordIterator) {\r\n                results.push(cursor.value);\r\n            }\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getRecordByIndex(searchData: IndexedDBQuerySearch) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await index.get(idbKeyResult.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllRecordsByIndexQuery(searchData: IndexedDBQuerySearch, count?: number) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await index.getAll(idbKeyResult.data.value, count)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllRecordsByIndex(searchData: IndexedDBQuerySearch) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await index.getAll()\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllKeysByIndex(searchData: IndexedDBQuerySearch, count?: number) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await index.getAllKeys(idbKeyResult.data.value, count)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getKeyByIndex(searchData: IndexedDBQuerySearch) {\r\n        try {\r\n            const { index, tx, idbKeyResult } = this.getIndexQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await index.getKey(idbKeyResult.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.indexName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName} index ${searchData.indexName}: ${e}`);\r\n        }\r\n    }\r\n    //#endregion\r\n\r\n    //#region StoreRecordQueries\r\n    public async iterateRecords(searchData: IndexedDBSearch, direction?: IDBCursorDirection) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results: any[] = [];\r\n            const recordIterator = objectStore.iterate(idbKeyResult.data.value, direction);\r\n            for await (const cursor of recordIterator) {\r\n                results.push(cursor.value);\r\n            }\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getRecord(searchData: IndexedDBSearch) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await objectStore.get(idbKeyResult.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from table ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records table ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllRecords(searchData: IndexedDBSearch) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await objectStore.getAll()\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllRecordsByQuery(searchData: IndexedDBSearch, count?: number) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await objectStore.getAll(idbKeyResult.data.value, count)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getAllKeys(searchData: IndexedDBSearch, count?: number) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await objectStore.getAllKeys(idbKeyResult.data.value, count)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n\r\n    public async getKey(searchData: IndexedDBSearch) {\r\n        try {\r\n            const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results = await objectStore.getKey(idbKeyResult.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`Records retrieved from index ${searchData.storeName}`, results);\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records from ${searchData.storeName}: ${e}`);\r\n        }\r\n    }\r\n    //#endregion\r\n\r\n\r\n    private getIDBKey(query: IndexedDBQuery) {\r\n        let result: IndexedDBQueryConvertion | undefined;\r\n        console.log(query);\r\n        switch (query.queryType) {\r\n            case \"BoundQuery\":\r\n                result = { type: \"KeyRange\", value: IDBKeyRange.bound(query.lowerBound, query.upperBound, query.lowerOpen, query.upperOpen) };\r\n\r\n                break;\r\n            case \"LowerBoundQuery\":\r\n                result = { type: \"KeyRange\", value: IDBKeyRange.lowerBound(query.lowerBound, query.lowerOpen) };\r\n\r\n                break;\r\n            case \"UpperBoundQuery\":\r\n                result = { type: \"KeyRange\", value: IDBKeyRange.upperBound(query.upperBound, query.upperOpen) };\r\n\r\n                break;\r\n            case \"OnlyQuery\":\r\n                result = { type: \"KeyRange\", value: IDBKeyRange.only(query.value) };\r\n                break;\r\n            case \"ValidKeyQuery\":\r\n                result = { type: \"ValidKey\", value: query.value };\r\n                break;\r\n            default:\r\n                return this.getFailureResult(`Invalid query type ${(query as any).queryType}`);\r\n        }\r\n        return this.getSuccessResult<IndexedDBQueryConvertion>(\"IDBKey created\", result);\r\n    }\r\n\r\n\r\n    private getIndexQuery(searchData: IndexedDBQuerySearch, transactionMode: IDBTransactionMode) {\r\n        const { objectStore, tx, idbKeyResult } = this.getStoreQuery(searchData, transactionMode);\r\n        const index = objectStore.index(searchData.indexName);\r\n        return { index, tx, idbKeyResult };\r\n    }\r\n\r\n    private getStoreQuery(searchData: IndexedDBSearch, transactionMode: IDBTransactionMode) {\r\n        const tx = this.getTransaction(searchData.storeName, transactionMode);\r\n        const objectStore = tx.objectStore(searchData.storeName);\r\n        const idbKeyResult = this.getIDBKey(searchData.queryValue);\r\n        return { objectStore, tx, idbKeyResult };\r\n    }\r\n\r\n    private getTransaction(stName: string, mode: IDBTransactionMode) {\r\n        const tx = this.dbInstance!.transaction(stName, mode);\r\n        return tx;\r\n    }\r\n\r\n    private removePrimaryKeyPropertyIfAutoIncrement(objectStore: IDBPObjectStore<unknown, [string], string, \"readonly\" | \"readwrite\" | \"versionchange\">, data: any) {\r\n        if (!objectStore.autoIncrement || !objectStore.keyPath) {\r\n            return data;\r\n        }\r\n\r\n        if (!Array.isArray(objectStore.keyPath)) {\r\n            if (Object.hasOwn(data, objectStore.keyPath)) {\r\n                delete data[objectStore.keyPath];\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    private upgradeDatabase(upgradeDB: IDBPDatabase, dbStore: IDbStore, oldVersion: number, newVersion: number, transaction: IDBPTransaction<any, StoreNames<any>[], \"versionchange\">) {\r\n        const outcomes: IndexedDBActionResult<any>[] = [];\r\n        if (oldVersion < newVersion) {\r\n            //might not be needed\r\n            // for (const table of upgradeDB.objectStoreNames) {\r\n            //     if (!dbStore.stores.find(s => s.name === table)) {\r\n            //         upgradeDB.deleteObjectStore(table);\r\n            //         const message = `Store ${table} deleted as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n            //         outcomes.push(\r\n            //             this.getSuccessResult(message, undefined, \"TableDeleted\"));\r\n            //     }\r\n            // }\r\n\r\n            for (var store of dbStore.stores) {\r\n\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    outcomes.push(...this.addNewStore(upgradeDB, store, oldVersion, newVersion));\r\n                    continue;\r\n                }\r\n                const table = transaction.objectStore(store.name);\r\n                for (const indexSpec of store.indexes) {\r\n                    if (table.indexNames.contains(indexSpec.name)) {\r\n                        continue;\r\n                    }\r\n                    outcomes.push(this.createIndexForStore(indexSpec, table, oldVersion, newVersion));\r\n                }\r\n                //might not be needed\r\n                // for (const dbIndexName of table.indexNames) {\r\n                //     const dbIdxFound = store.indexes.find(i => i.name === String(dbIndexName));\r\n                //     if(!dbIdxFound){\r\n                //         table.deleteIndex(String(dbIndexName));\r\n                //         const message = `Index ${String(dbIndexName)} deleted inside ${store.name} as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n                //         outcomes.push(this.getSuccessResult(message, undefined, \"IndexDeleted\"));\r\n                //     }\r\n                // }\r\n            }\r\n\r\n        }\r\n        return outcomes;\r\n    }\r\n\r\n\r\n\r\n    private async verifySchema(upgradeDB: IDBPDatabase, dbStore: IDbStore) {\r\n        const result: IndexedDBActionResult<undefined>[] = [];\r\n        if (dbStore.stores) {\r\n            for (var store of dbStore.stores) {\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    result.push(\r\n                        this.getFailureResult(`Store ${store.name} not found in database`, \"StoreNotFound\"));\r\n                    continue;\r\n                }\r\n\r\n                const tx = upgradeDB.transaction(store.name, \"readonly\");\r\n                const table = tx.objectStore(store.name);\r\n                for (const appIndex of store.indexes) {\r\n                    if (!table.indexNames.contains(appIndex.name)) {\r\n                        result.push(\r\n                            this.getFailureResult(`Index ${appIndex.name} not found in store ${store.name}`, \"IndexNotFound\"));\r\n                        continue;\r\n                    }\r\n                    const idx = table.index(appIndex.name);\r\n                    if (Array.isArray(idx.keyPath)) {\r\n                        for (const idxKey of idx.keyPath) {\r\n                            if (!appIndex.keyPath.includes(idxKey)) {\r\n                                result.push(\r\n                                    this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, \"IndexKeyPathMismatch\"));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!appIndex.keyPath.includes(idx.keyPath)) {\r\n                            result.push(\r\n                                this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, \"IndexKeyPathMismatch\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private addNewStore(upgradeDB: IDBPDatabase, store: IStoreSchema, oldVersion: number, newVersion: number) {\r\n        const storeOutcomes: IndexedDBActionResult<any>[] = []\r\n        let primaryKey = store.primaryKey;\r\n\r\n        if (!primaryKey) {\r\n            primaryKey = { name: \"id\", keyPath: [\"id\"], auto: true, multiEntry: false, unique: true, keepAsArrayOnSingleValue: false };\r\n        }\r\n        const primaryKeyPath = primaryKey.keyPath.length == 1 ? primaryKey.keyPath[0] : primaryKey.keyPath;\r\n\r\n        try {\r\n\r\n            const newStore = upgradeDB.createObjectStore(store.name, { keyPath: primaryKeyPath, autoIncrement: primaryKey.auto });\r\n            storeOutcomes.push(this.getSuccessResult(`Store ${store.name} created inside ${upgradeDB.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`, undefined, \"TableCreated\"));\r\n            for (var index of store.indexes) {\r\n                storeOutcomes.push(this.createIndexForStore(index, newStore, oldVersion, newVersion));\r\n            }\r\n        }\r\n        catch (e) {\r\n            storeOutcomes.push(this.getFailureResult(`Error creating store ${store.name}: ${e}`, \"StoreCreationError\"));\r\n        }\r\n        return storeOutcomes;\r\n    }\r\n\r\n\r\n\r\n    private createIndexForStore(index: IIndexSpec, newStore: IDBPObjectStore<unknown, string[], string, \"versionchange\">, oldVersion: number, newVersion: number) {\r\n        let keyPath: string | string[] = index.keyPath;\r\n        if (index.keyPath.length === 1 && !index.keepAsArrayOnSingleValue) {\r\n            keyPath = index.keyPath[0];\r\n        }\r\n\r\n        if (index.multiEntry && index.keyPath.length > 1) {\r\n            return this.getFailureResult(`Index ${index.name} has multiEntry set to true but has multiple keyPaths. This is not supported.`, \"MultiEntryIndexWithMultipleKeyPaths\");\r\n        }\r\n        if (index.multiEntry && index.keyPath.length === 1) {\r\n            //TODO: handle multiEntry indexes with multiple keyPaths\r\n            keyPath = index.keyPath[0];\r\n        }\r\n        try {\r\n            newStore.createIndex(index.name, keyPath, { unique: index.unique, multiEntry: index.multiEntry });\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error creating index ${index.name} for store ${newStore.name}: ${e}`, \"IndexCreationError\");\r\n        }\r\n        const message = `Index ${index.name} created inside ${newStore.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`;\r\n        return this.getSuccessResult(message, undefined, \"IndexCreated\");\r\n    }\r\n\r\n    private getSuccessResult<T extends any>(successMessage: string, data: T, type?: string): IndexedDBActionResultSuccess<T> {\r\n        const result: IndexedDBActionResultSuccess<T> = {\r\n            success: true,\r\n            data,\r\n            message: successMessage,\r\n            type\r\n        }\r\n        console.log(result);\r\n        return result;\r\n    }\r\n    private getFailureResult(errorMessage: string, type?: string): IndexedDBActionResultFailure {\r\n        const result: IndexedDBActionResultFailure = {\r\n            success: false,\r\n            data: undefined,\r\n            message: errorMessage,\r\n            type\r\n        }\r\n        console.log(result);\r\n        return result;\r\n    }\r\n    private async ensureDatabaseOpen(dbName: string) {\r\n        if (!this.dbInstance) {\r\n            this.dbInstance = await openDB(dbName);\r\n        }\r\n    }\r\n\r\n}", "\uFEFFimport { IndexedDbManager } from './indexedDbBlazor';\r\nimport { type DotNet } from \"@microsoft/dotnet-js-interop\";\r\n\r\nexport let IDBManager: IndexedDbManager | undefined;\r\nlet _dbManagerRef: DotNet.DotNetObject | undefined;\r\nexport function initIndexedDbManager(dbManagerRef: DotNet.DotNetObject) {\r\n    if (IDBManager) { return; }\r\n    IDBManager = new IndexedDbManager(dbManagerRef);\r\n    (window as any).dbManager = IDBManager;\r\n    _dbManagerRef = dbManagerRef;\r\n    console.log(\"IndexedDbManager initialized\");\r\n}"],
  "mappings": "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",
  "names": ["target", "message"]
}
