{
  "version": 3,
  "sources": ["../node_modules/idb/build/index.js", "../client/indexedDbBlazor.ts", "../client/app.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "\uFEFFimport { IDBPObjectStore, IDBPDatabase, openDB, deleteDB, TypedDOMStringList, StoreNames } from \"idb\";\r\nimport { IDbStore, IIndexSearch, IStoreRecord, IStoreSchema, IDbInformation } from \"./InteropInterfaces\";\r\nimport { DotNet } from \"@microsoft/dotnet-js-interop\";\r\n// import { UPGRADE_CHANNEL } from \"./utils\";\r\nconst RAISE_EVENT_METHOD = \"RaiseNotificationFromJS\";\r\nexport class IndexedDbManager {\r\n\r\n    private dbInstance: IDBPDatabase | undefined;\r\n    private _dbManagerRef: DotNet.DotNetObject;\r\n    // private upgradeChannel: BroadcastChannel; \r\n\r\n    constructor(dbManagerRef: DotNet.DotNetObject) {\r\n        this._dbManagerRef = dbManagerRef;\r\n        // this.upgradeChannel = new BroadcastChannel(UPGRADE_CHANNEL);\r\n        // this.upgradeChannel.addEventListener(\"message\", this.upgradeChannelMessageHandler)\r\n    }\r\n\r\n    private upgradeChannelMessageHandler = (ev: MessageEvent) => {\r\n        console.log(\"Upgrade message received.\");\r\n        if (this.dbInstance) {\r\n            this.dbInstance?.close();\r\n        }\r\n    }\r\n\r\n    public async openDb(data: IDbStore) {\r\n        const dbStore = data;\r\n        try {\r\n            if (!this.dbInstance || this.dbInstance.version < dbStore.version) {\r\n                if (this.dbInstance) {\r\n                    this.dbInstance.close();\r\n                }\r\n                this.dbInstance = await openDB(dbStore.dbName, dbStore.version, {\r\n                    upgrade: async (database, oldVersion, newVersion) => {\r\n                        await this.upgradeDatabase(database, dbStore, oldVersion, newVersion!);\r\n                    },\r\n                    blocked: async (currentVersion, blockedVersion, event) => {\r\n                        const msg = `Database upgrade blocked. Current version: ${currentVersion}, Blocked version: ${blockedVersion}`;\r\n                        console.warn(msg, event);\r\n                        await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"DatabaseUpgradeBlocked\", msg)\r\n\r\n                    },\r\n                    blocking: async (currentVersion, blockedVersion, event) => {\r\n                        const msg = `Database upgrade blocking. Current version: ${currentVersion}, Blocked version: ${blockedVersion}`;\r\n                        console.warn(msg, event);\r\n                        await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"DatabaseUpgradeBlocking\", msg)\r\n                        this.dbInstance?.close();\r\n                    }\r\n                });\r\n            }\r\n        } catch (e) {\r\n            const msg = `Could not open db, will try again. ${e}`;\r\n            console.error(msg);\r\n            this.dbInstance = await openDB(dbStore.dbName);\r\n            await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"DatabaseOpenFailure\", msg)\r\n\r\n        }\r\n        const result = await this.verifySchema(this.dbInstance, dbStore);\r\n        if (result.success === false) {\r\n            await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"SchemaVerificationFailure\", result.message)\r\n        }\r\n        const msg = `IndexedDB ${data.dbName} opened`;\r\n        await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"DatabaseOpened\", msg)\r\n        return msg;\r\n    }\r\n\r\n    public async getDbInfo(dbName: string) {\r\n        if (!this.dbInstance) {\r\n            this.dbInstance = await openDB(dbName);\r\n        }\r\n\r\n        const currentDb = <IDBPDatabase>this.dbInstance;\r\n\r\n        const getStoreNames = (list: TypedDOMStringList<StoreNames<any>>) => {\r\n            const names: string[] = [];\r\n            for (const element of list) {\r\n                console.log(element);\r\n            }\r\n            for (var i = 0; i < list.length; i++) {\r\n                names.push(list[i]);\r\n            }\r\n            return names;\r\n        }\r\n        const dbInfo: IDbInformation = {\r\n            version: currentDb.version,\r\n            storeNames: getStoreNames(currentDb.objectStoreNames)\r\n        };\r\n\r\n        return dbInfo;\r\n    }\r\n\r\n    public async deleteDb(dbName: string): Promise<string> {\r\n        this.dbInstance?.close();\r\n\r\n        await deleteDB(dbName);\r\n\r\n        this.dbInstance = undefined;\r\n        const msg = `The database ${dbName} has been deleted.`;\r\n        await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"DatabaseDeleted\", msg)\r\n\r\n        return msg;\r\n    }\r\n\r\n    public async addRecord(record: IStoreRecord) {\r\n        const stName = record.storeName;\r\n        let itemToSave = record.data;\r\n        const tx = this.getTransaction(stName, \"readwrite\");\r\n        const objectStore = tx.objectStore(stName);\r\n\r\n        itemToSave = this.checkForKeyPath(objectStore, itemToSave);\r\n\r\n        const result = await objectStore.add?.(itemToSave, record.key);\r\n        await tx.done;\r\n        return `Added new record with id ${result}`;\r\n    }\r\n\r\n    public updateRecord = async (record: IStoreRecord): Promise<string> => {\r\n        const stName = record.storeName;\r\n        const tx = this.getTransaction(stName, \"readwrite\");\r\n\r\n        const result = await tx.objectStore(stName).put?.(record.data, record.key);\r\n\r\n        return `updated record with id ${result}`;\r\n    }\r\n\r\n    public getRecords = async (storeName: string): Promise<any> => {\r\n        const tx = this.getTransaction(storeName, \"readonly\");\r\n\r\n        let results = await tx.objectStore(storeName).getAll();\r\n\r\n        await tx.done;\r\n\r\n        return results;\r\n    }\r\n\r\n    public clearStore = async (storeName: string): Promise<string> => {\r\n\r\n        const tx = this.getTransaction(storeName, \"readwrite\");\r\n\r\n        await tx.objectStore(storeName).clear?.();\r\n        await tx.done;\r\n\r\n        return `Store ${storeName} cleared`;\r\n    }\r\n\r\n    public getRecordByIndex = async (searchData: IIndexSearch): Promise<any> => {\r\n        const tx = this.getTransaction(searchData.storeName, \"readonly\");\r\n        const results = await tx.objectStore(searchData.storeName)\r\n            .index(searchData.indexName)\r\n            .get(searchData.queryValue);\r\n\r\n        await tx.done;\r\n        return results;\r\n    }\r\n\r\n    public getAllRecordsByIndex = async (searchData: IIndexSearch): Promise<any> => {\r\n        const tx = this.getTransaction(searchData.storeName, \"readonly\");\r\n        const results: any[] = [];\r\n        // const indexToSearch = tx.objectStore(searchData.storeName)\r\n        //     .index(searchData.indexName);\r\n        // IDBKeyRange.bound(\"a\", `a${(\"\\uffff\")}`)\r\n        const recordIterator = tx.objectStore(searchData.storeName)\r\n            .index(searchData.indexName)\r\n            .iterate(searchData.queryValue, \"next\")\r\n        for await (const cursor of recordIterator) {\r\n            results.push(cursor.value);\r\n        }\r\n        await tx.done;\r\n        console.log(recordIterator);\r\n\r\n        return results;\r\n    }\r\n\r\n    public getRecordById = async (storename: string, id: any): Promise<any> => {\r\n\r\n        const tx = this.getTransaction(storename, \"readonly\");\r\n\r\n        let result = await tx.objectStore(storename).get(id);\r\n        return result;\r\n    }\r\n\r\n    public deleteRecord = async (storename: string, id: any): Promise<string> => {\r\n        const tx = this.getTransaction(storename, \"readwrite\");\r\n        await tx.objectStore(storename).delete?.(id);\r\n\r\n        return `Record with id: ${id} deleted`;\r\n    }\r\n\r\n    private getTransaction(stName: string, mode?: IDBTransactionMode) {\r\n        const tx = this.dbInstance!.transaction(stName, mode);\r\n        tx.done.catch(\r\n            err => {\r\n                if (err) {\r\n                    console.error((err as Error).message);\r\n                } else {\r\n                    console.error(\"Undefined error in getTransaction()\");\r\n                }\r\n\r\n            });\r\n\r\n        return tx;\r\n    }\r\n\r\n    // Currently don\"t support aggregate keys\r\n    private checkForKeyPath(objectStore: IDBPObjectStore<unknown, [string], string, \"readonly\" | \"readwrite\" | \"versionchange\">, data: any) {\r\n        if (!objectStore.autoIncrement || !objectStore.keyPath) {\r\n            return data;\r\n        }\r\n\r\n        if (typeof objectStore.keyPath !== \"string\") {\r\n            return data;\r\n        }\r\n\r\n        const keyPath = objectStore.keyPath as string;\r\n\r\n        if (!data[keyPath]) {\r\n            delete data[keyPath];\r\n        }\r\n        return data;\r\n    }\r\n\r\n    private async upgradeDatabase(upgradeDB: IDBPDatabase, dbStore: IDbStore, oldVersion: number, newVersion: number) {\r\n        if (oldVersion < newVersion) {\r\n            if (dbStore.stores) {\r\n                for (var store of dbStore.stores) {\r\n                    if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                        this.addNewStore(upgradeDB, store);\r\n                        const msg = `Store ${store.name} created inside ${upgradeDB.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`;\r\n                        await this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, \"TableCreated\", msg)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async verifySchema(upgradeDB: IDBPDatabase, dbStore: IDbStore) {\r\n        const result = {\r\n            success: true,\r\n            message: \"\"\r\n        }\r\n        if (dbStore.stores) {\r\n            for (var store of dbStore.stores) {\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    result.success = false;\r\n                    result.message += `\\r\\nStore ${store.name} not found in database`;\r\n                }\r\n                const a = await upgradeDB.getAll(store.name);\r\n                const b = await upgradeDB.getAllKeys(store.name);\r\n                console.log(a, b);\r\n\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private addNewStore(upgradeDB: IDBPDatabase, store: IStoreSchema) {\r\n        let primaryKey = store.primaryKey;\r\n\r\n        if (!primaryKey) {\r\n            primaryKey = { name: \"id\", keyPath: \"id\", auto: true };\r\n        }\r\n\r\n        const newStore = upgradeDB.createObjectStore(store.name, { keyPath: primaryKey.keyPath, autoIncrement: primaryKey.auto });\r\n\r\n        for (var index of store.indexes) {\r\n            newStore.createIndex(index.name, index.keyPath, { unique: index.unique });\r\n        }\r\n    }\r\n}", "\uFEFFimport { IndexedDbManager } from './indexedDbBlazor';\r\nimport { DotNet } from \"@microsoft/dotnet-js-interop\";\r\n\r\nexport let IDBManager: IndexedDbManager | undefined;\r\nlet _dbManagerRef: DotNet.DotNetObject | undefined;\r\nexport function initIndexedDbManager(dbManagerRef: DotNet.DotNetObject) {\r\n    if (IDBManager) { return; }\r\n    IDBManager = new IndexedDbManager(dbManagerRef);\r\n    _dbManagerRef = dbManagerRef;\r\n    console.log(\"IndexedDbManager initialized\");\r\n}"],
  "mappings": "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",
  "names": ["target", "msg"]
}
