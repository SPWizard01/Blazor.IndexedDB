{
  "version": 3,
  "sources": ["../node_modules/idb/build/index.js", "../client/indexedDbBlazor.ts", "../client/app.ts"],
  "sourcesContent": ["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "\uFEFFimport { IDBPObjectStore, IDBPDatabase, openDB, deleteDB, TypedDOMStringList, StoreNames, IDBPTransaction } from \"idb\";\r\nimport { IIndexedDBDatabase, IStoreSchema, DBInformation, IIndexSpec, IIndexedDBDatabaseInstance, IndexedDBCursorQuery, IndexedDBJSConfig } from \"./models/InteropInterfaces\";\r\nimport { DotNet } from \"@microsoft/dotnet-js-interop\";\r\nimport { IndexedDBActionResult, IndexedDBActionResultFailure, IndexedDBActionResultSuccess, IndexedDBActionResultType } from \"./models/actionResult\";\r\nimport { IndexedDBQueryType, IndexedDBQueryConvertion, IndexedDBQuery } from \"./models/queryValue\";\r\nimport { IndexedDBRecordAction, IndexedDBObjectBase } from \"./models/record\";\r\n// import { UPGRADE_CHANNEL } from \"./utils\";\r\nconst RAISE_EVENT_METHOD = \"RaiseNotificationFromJS\";\r\n//https://web.dev/articles/indexeddb\r\nexport class IndexedDbManager {\r\n\r\n    private instances: IIndexedDBDatabaseInstance[] = [];\r\n    private _dbManagerRef: DotNet.DotNetObject;\r\n    private _sendNotifications = false;\r\n\r\n    constructor(instanceConfig: IndexedDBJSConfig) {\r\n        this._dbManagerRef = instanceConfig.dotNetReference;\r\n        this._sendNotifications = instanceConfig.sendNotificationsFromJS;\r\n    }\r\n\r\n\r\n    public async openDb(indexedDatabase: IIndexedDBDatabase) {\r\n        const dbOpenOutcomes: IndexedDBActionResult<any>[] = [];\r\n        let dbInstance = this.getInstance(indexedDatabase.name);\r\n        try {\r\n            if (!dbInstance || dbInstance.instance.version < indexedDatabase.version) {\r\n                if (dbInstance) {\r\n                    dbInstance.instance.close();\r\n                    this.instances.splice(this.instances.indexOf(dbInstance), 1);\r\n                }\r\n\r\n                const instance = await openDB(indexedDatabase.name, indexedDatabase.version, {\r\n                    upgrade: async (database, oldVersion, newVersion, transaction) => {\r\n\r\n                        const outcomes = this.upgradeDatabase(database, indexedDatabase, oldVersion, newVersion!, transaction);\r\n                        await transaction.done;\r\n                        dbOpenOutcomes.push(...outcomes);\r\n                    },\r\n                    blocked: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocked. Current version: ${currentVersion}, Blocked version: ${blockedVersion}`;\r\n                        console.warn(message, event);\r\n                        dbOpenOutcomes.push(\r\n                            this.getFailureResult(message, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseUpgradeBlocked\"));\r\n                    },\r\n                    blocking: async (currentVersion, blockedVersion, event) => {\r\n                        const message = `Database upgrade blocking. Current version: ${currentVersion}, Blocked version: ${blockedVersion}, trying to close db.`;\r\n                        console.warn(message, event);\r\n                        try {\r\n                            let blockingInstance = this.getInstance(indexedDatabase.name);;\r\n                            blockingInstance?.instance.close();\r\n                            const baseInfo: IndexedDBObjectBase = { databaseName: indexedDatabase.name, storeName: \"\" };\r\n\r\n                            dbOpenOutcomes.push(\r\n                                this.getSuccessResult(message, undefined, baseInfo, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                        catch (e) {\r\n                            const message = `Could not close db, will try again. ${e}`;\r\n                            console.error(message);\r\n                            dbOpenOutcomes.push(\r\n                                this.getFailureResult(message, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseUpgradeBlocking\")\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n                dbInstance = { name: indexedDatabase.name, instance, executingCursors: [] };\r\n                this.instances.push(dbInstance);\r\n            }\r\n        } catch (e) {\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(`Could not open db ${e}`, { databaseName: indexedDatabase.name, storeName: \"\" }, \"DatabaseOpenError\")\r\n            );\r\n            return dbOpenOutcomes;\r\n        }\r\n        try {\r\n            const result = await this.verifySchema(dbInstance.instance, indexedDatabase);\r\n            dbOpenOutcomes.push(...result);\r\n\r\n        }\r\n        catch (e) {\r\n            dbOpenOutcomes.push(\r\n                this.getFailureResult(`Could not verify schema ${e}`, { databaseName: indexedDatabase.name, storeName: \"\" }, \"SchemaVerificationError\")\r\n            );\r\n        }\r\n\r\n        return dbOpenOutcomes;\r\n    }\r\n\r\n    public async deleteDb(databaseName: string) {\r\n        try {\r\n            const db = this.getInstance(databaseName);\r\n            db?.instance.close();\r\n\r\n            await deleteDB(databaseName);\r\n            if (db) {\r\n                this.instances.splice(this.instances.indexOf(db), 1);\r\n            }\r\n            const msg = `The database ${databaseName} has been deleted.`;\r\n            return this.getSuccessResult(msg, undefined, { databaseName, storeName: \"\" }, \"DatabaseDeleted\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting database: ${e}`, { databaseName, storeName: \"\" }, \"DatabaseDeleteError\");\r\n        }\r\n    }\r\n\r\n    public async getDatabaseInfo(databaseName: string) {\r\n        try {\r\n            const instance = this.getInstance(databaseName)!.instance;\r\n            const dbInfo: DBInformation = {\r\n                name: instance.name,\r\n                version: instance.version,\r\n                storeNames: this.getStoreNames(instance.objectStoreNames)\r\n            };\r\n\r\n            return this.getSuccessResult(\"Database information retrieved\", dbInfo, { databaseName: instance.name, storeName: \"\" }, \"DatabaseInfo\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting database information: ${e}`, { databaseName, storeName: \"\" }, \"DatabaseInfoError\");\r\n        }\r\n    }\r\n\r\n    //#region CRUD\r\n    public async addRecord(record: IndexedDBRecordAction) {\r\n        let itemToSave = record.data;\r\n        try {\r\n            const { tx, objectStore, idbKeyResult } = this.getStoreQuery(record, \"readwrite\");\r\n            itemToSave = this.removePrimaryKeyPropertyIfAutoIncrement(objectStore, itemToSave);\r\n            if (!objectStore.add) {\r\n                return this.getFailureResult(\"Add method not available on object store\", record, \"RecordQueryError\");\r\n            }\r\n            let key: IDBValidKey | IDBKeyRange | undefined = undefined;\r\n            if (!idbKeyResult.success && record.useKey) {\r\n                return this.getFailureResult(\"Unable to update record, key not valid\", record, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.success && record.useKey) {\r\n                key = idbKeyResult.result.data.value;\r\n            }\r\n\r\n            const result = await objectStore.add(itemToSave, key);\r\n            const dbResult = await objectStore.get(result);\r\n            await tx.done;\r\n            const msg = `Added new record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult, record, \"Record\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error adding record: ${e}`, record, \"RecordQueryError\");\r\n        }\r\n\r\n    }\r\n\r\n    public async updateRecord(record: IndexedDBRecordAction) {\r\n        try {\r\n            const { tx, idbKeyResult, objectStore } = this.getStoreQuery(record, \"readwrite\");\r\n            if (!objectStore.put) {\r\n                return this.getFailureResult(\"Put method not available on object store\", record, \"RecordQueryError\");\r\n            }\r\n            let key: IDBValidKey | IDBKeyRange | undefined = undefined;\r\n            if (!idbKeyResult.success && record.useKey) {\r\n                return this.getFailureResult(\"Unable to update record, key not valid\", record, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.success && record.useKey) {\r\n                key = idbKeyResult.result.data.value;\r\n            }\r\n\r\n            const result = await objectStore.put(record.data, key);\r\n            const dbResult = await objectStore.get(result);\r\n            await tx.done;\r\n            const msg = `Updated record with id ${result}`;\r\n            return this.getSuccessResult(msg, dbResult, record, \"Record\");\r\n\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error updating record: ${e}`, record, \"RecordQueryError\");\r\n        }\r\n    }\r\n\r\n    public async deleteRecord(query: IndexedDBQuery) {\r\n        try {\r\n            const { tx, objectStore, idbKeyResult } = this.getStoreQuery(query, \"readwrite\");\r\n            if (!objectStore.delete) {\r\n                return this.getFailureResult(\"delete method not available on object store\", query, \"RecordQueryError\");\r\n            }\r\n            if (!idbKeyResult.success) {\r\n                return this.getFailureResult(`Error deleting record: ${idbKeyResult.message}`, query, \"RecordQueryError\");\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`Error deleting record: NoQuery is not a valid query`, query, \"RecordQueryError\");\r\n            }\r\n            await objectStore.delete(idbKeyResult.result.data.value);\r\n            await tx.done;\r\n            return this.getSuccessResult(`Deleted records from store ${query.storeName}`, undefined, query, \"RecordDeleted\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error deleting record: ${e}`, query, \"RecordQueryError\");\r\n        }\r\n    }\r\n\r\n    public async clearStore(record: IndexedDBObjectBase) {\r\n\r\n        try {\r\n            const { tx, objectStore } = this.getTransaction(record, \"readwrite\");\r\n            if (!objectStore.clear) {\r\n                return this.getFailureResult(\"Clear method not available on object store\", record, \"StoreQueryError\");\r\n            }\r\n            await objectStore.clear();\r\n            await tx.done;\r\n            return this.getSuccessResult(`Store ${record.storeName} cleared`, undefined, record, \"StoreCleared\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error clearing store ${record.storeName}: ${e}`, record, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    //#endregion\r\n\r\n    //#region StoreRecordQueries\r\n\r\n    public async openCursor(searchData: IndexedDBQuery, direction?: IDBCursorDirection) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n            if (executingCursor) {\r\n                return this.getFailureResult(`Another cursor is already open`, searchData, \"CursorFailure\");\r\n            }\r\n            const query = idbKeyResult.result.data.value;\r\n            const queryObject = index ?? objectStore;\r\n            const rs = await queryObject.openCursor(query, direction);\r\n            await tx.done;\r\n            if (rs?.value) {\r\n                instance.executingCursors.push({ initialQuery: searchData, cursorPosition: 1, direction });\r\n                return this.getSuccessResult(`Cursor result ${queryPath}`, rs.value, searchData, \"CursorRecord\");\r\n\r\n            }\r\n            return this.getSuccessResult(`Cursor result ${queryPath}`, undefined, searchData, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async advanceCursor(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n            if (executingCursor) {\r\n                const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(executingCursor.initialQuery, \"readonly\");\r\n                if (!idbKeyResult.success) {\r\n                    return idbKeyResult\r\n                }\r\n                const query = idbKeyResult.result.data.value;\r\n                const queryObject = index ?? objectStore;\r\n                const rs = await queryObject.openCursor(query, executingCursor.direction);\r\n                const next = await rs?.advance(executingCursor.cursorPosition);\r\n                await tx.done;\r\n                if (!next || !next.value) {\r\n                    instance.executingCursors.splice(instance.executingCursors.indexOf(executingCursor), 1);\r\n                    return this.getSuccessResult(`No more records ${queryPath}`, undefined, searchData, \"CursorClosed\");\r\n                }\r\n                executingCursor.cursorPosition += 1;\r\n                return this.getSuccessResult(`Cursor record ${queryPath}`, next.value, searchData, \"CursorRecord\");\r\n\r\n            }\r\n            return this.getSuccessResult(`No cursor is open ${queryPath}`, undefined, searchData, \"CursorNotOpen\");\r\n\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n    public async closeCursor(searchData: IndexedDBQuery) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            const executingCursor = this.getInstanceExecutingCursor(instance, searchData);\r\n\r\n            if (!executingCursor) {\r\n                return this.getSuccessResult(`No cursor is open`, undefined, searchData, \"CursorNotOpen\");\r\n            }\r\n            instance.executingCursors.splice(instance.executingCursors.indexOf(executingCursor), 1);\r\n            return this.getSuccessResult(``, undefined, searchData, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async closeAllStoreCursors(searchData: IndexedDBObjectBase) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            instance.executingCursors = instance.executingCursors.filter(c =>\r\n                c.initialQuery.databaseName !== searchData.databaseName &&\r\n                c.initialQuery.storeName !== searchData.storeName\r\n            );\r\n            return this.getSuccessResult(``, undefined, searchData, \"CursorNoMoreRecords\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, searchData, \"CursorFailure\");\r\n        }\r\n    }\r\n    public async closeAllCursors(searchData: IndexedDBObjectBase) {\r\n        try {\r\n            const instance = this.getInstance(searchData.databaseName)!;\r\n            instance.executingCursors = [];\r\n            return this.getSuccessResult(``, undefined, { databaseName: searchData.databaseName, storeName: \"\" }, \"CursorClosed\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error closing cursor: ${e}`, { databaseName: searchData.databaseName, storeName: \"\" }, \"CursorFailure\");\r\n        }\r\n    }\r\n\r\n    public async iterateRecords(searchData: IndexedDBQuery, direction?: IDBCursorDirection) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const results: any[] = [];\r\n            const queryObject = index ?? objectStore;\r\n            const recordIterator = queryObject.iterate(idbKeyResult.result.data.value, direction);\r\n            for await (const cursor of recordIterator) {\r\n                results.push(cursor.value);\r\n            }\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} records retrieved ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getRecord(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`NoQuery is not a valid query`, searchData, \"RecordQueryError\");\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.get(idbKeyResult.result.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results ? \"1\" : \"0\"} record retrieved ${queryPath}`, results, searchData, results ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting record: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getAllRecords(searchData: IndexedDBQuery, count: number) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getAll(idbKeyResult.result.data.value, count > 0 ? count : undefined)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} records retrieved from ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting records: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getAllKeys(searchData: IndexedDBQuery, count: number) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getAllKeys(idbKeyResult.result.data.value, count > 0 ? count : undefined)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results.length} keys retrieved from ${queryPath}`, results, searchData, results.length > 0 ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting keys: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n\r\n    public async getKey(searchData: IndexedDBQuery) {\r\n        try {\r\n            const queryPath = this.getQueryPath(searchData)\r\n\r\n            const { objectStore, tx, idbKeyResult, index } = this.getStoreQuery(searchData, \"readonly\");\r\n            if (!idbKeyResult.success) {\r\n                return idbKeyResult\r\n            }\r\n            if (idbKeyResult.result.data.type === \"NoQuery\") {\r\n                return this.getFailureResult(`NoQuery is not a valid query`, searchData, \"RecordQueryError\");\r\n            }\r\n            const queryObject = index ?? objectStore;\r\n            const results = await queryObject.getKey(idbKeyResult.result.data.value)\r\n            await tx.done;\r\n            return this.getSuccessResult(`${results ? \"1\" : \"0\"} keys retrieved from ${queryPath}`, results, searchData, results ? \"Record\" : \"RecordNotFound\");\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error getting keys: ${e}`, searchData, \"StoreQueryError\");\r\n        }\r\n    }\r\n    //#endregion\r\n\r\n    private getIDBKey(incommingQuery: IndexedDBQuery) {\r\n        let result: IndexedDBQueryConvertion | undefined;\r\n        const query = incommingQuery.queryValue;\r\n        try {\r\n            switch (query.queryType) {\r\n                case \"BoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.bound(query.lower, query.upper, query.lowerOpen, query.upperOpen) };\r\n\r\n                    break;\r\n                case \"LowerBoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.lowerBound(query.lowerBound, query.lowerOpen) };\r\n\r\n                    break;\r\n                case \"UpperBoundQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.upperBound(query.upperBound, query.upperOpen) };\r\n\r\n                    break;\r\n                case \"OnlyQuery\":\r\n                    result = { type: \"KeyRange\", value: IDBKeyRange.only(query.value) };\r\n                    break;\r\n                case \"ValidKeyQuery\":\r\n                    result = { type: \"ValidKey\", value: query.value };\r\n                    break;\r\n                case \"NoQuery\":\r\n                    result = { type: \"NoQuery\", value: undefined };\r\n                    break;\r\n                default:\r\n                    return this.getFailureResult(`Invalid query type ${(query as any).queryType}`, incommingQuery, \"IDBKeyFailure\");\r\n            }\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Failed to create key ${e}`, incommingQuery, \"IDBKeyFailure\");\r\n        }\r\n        return this.getSuccessResult(\"\", result, incommingQuery, \"IDBKeyCreated\");\r\n    }\r\n\r\n    private getStoreQuery(searchData: IndexedDBQuery, transactionMode: IDBTransactionMode) {\r\n        const { tx, objectStore } = this.getTransaction(searchData, transactionMode);\r\n        const idbKeyResult = this.getIDBKey(searchData);\r\n        const index = searchData.indexName ? objectStore.index(searchData.indexName) : undefined;\r\n        return { objectStore, tx, idbKeyResult, index };\r\n    }\r\n\r\n    private getTransaction(searchData: IndexedDBObjectBase, mode: IDBTransactionMode) {\r\n        const db = this.getInstance(searchData.databaseName);\r\n        const tx = db!.instance.transaction(searchData.storeName, mode);\r\n        const objectStore = tx.objectStore(searchData.storeName);\r\n        return { tx, objectStore };\r\n    }\r\n\r\n    private removePrimaryKeyPropertyIfAutoIncrement(objectStore: IDBPObjectStore<unknown, [string], string, \"readonly\" | \"readwrite\" | \"versionchange\">, data: any) {\r\n        if (!objectStore.autoIncrement || !objectStore.keyPath) {\r\n            return data;\r\n        }\r\n\r\n        if (!Array.isArray(objectStore.keyPath)) {\r\n            if (Object.hasOwn(data, objectStore.keyPath)) {\r\n                delete data[objectStore.keyPath];\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    private upgradeDatabase(upgradeDB: IDBPDatabase, dbStore: IIndexedDBDatabase, oldVersion: number, newVersion: number, transaction: IDBPTransaction<any, StoreNames<any>[], \"versionchange\">) {\r\n        const outcomes: IndexedDBActionResult<any>[] = [];\r\n        if (oldVersion < newVersion) {\r\n            //might not be needed\r\n            // for (const table of upgradeDB.objectStoreNames) {\r\n            //     if (!dbStore.stores.find(s => s.name === table)) {\r\n            //         upgradeDB.deleteObjectStore(table);\r\n            //         const message = `Store ${table} deleted as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n            //         outcomes.push(\r\n            //             this.getSuccessResult(message, undefined, \"TableDeleted\"));\r\n            //     }\r\n            // }\r\n\r\n            for (var store of dbStore.stores) {\r\n\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    outcomes.push(...this.addNewStore(upgradeDB, store, oldVersion, newVersion));\r\n                    continue;\r\n                }\r\n                const table = transaction.objectStore(store.name);\r\n                for (const indexSpec of store.indexes) {\r\n                    if (table.indexNames.contains(indexSpec.name)) {\r\n                        continue;\r\n                    }\r\n                    outcomes.push(this.createIndexForStore(indexSpec, table, oldVersion, newVersion));\r\n                }\r\n                //might not be needed\r\n                // for (const dbIndexName of table.indexNames) {\r\n                //     const dbIdxFound = store.indexes.find(i => i.name === String(dbIndexName));\r\n                //     if(!dbIdxFound){\r\n                //         table.deleteIndex(String(dbIndexName));\r\n                //         const message = `Index ${String(dbIndexName)} deleted inside ${store.name} as it was not found in the schema when upgrading from v${oldVersion} to v${newVersion}`;\r\n                //         outcomes.push(this.getSuccessResult(message, undefined, \"IndexDeleted\"));\r\n                //     }\r\n                // }\r\n            }\r\n\r\n        }\r\n        return outcomes;\r\n    }\r\n\r\n    private async verifySchema(upgradeDB: IDBPDatabase, database: IIndexedDBDatabase) {\r\n        const result: IndexedDBActionResult<undefined>[] = [];\r\n        if (database.stores) {\r\n            for (var store of database.stores) {\r\n                const processingObject = { databaseName: database.name, storeName: store.name };\r\n                if (!upgradeDB.objectStoreNames.contains(store.name)) {\r\n                    result.push(\r\n                        this.getFailureResult(`Store ${store.name} not found in database`, processingObject, \"StoreNotFound\"));\r\n                    continue;\r\n                }\r\n\r\n                const tx = upgradeDB.transaction(store.name, \"readonly\");\r\n                const table = tx.objectStore(store.name);\r\n                for (const appIndex of store.indexes) {\r\n                    if (!table.indexNames.contains(appIndex.name)) {\r\n                        result.push(\r\n                            this.getFailureResult(`Index ${appIndex.name} not found in store ${store.name}`, processingObject, \"IndexNotFound\"));\r\n                        continue;\r\n                    }\r\n                    const idx = table.index(appIndex.name);\r\n                    if (Array.isArray(idx.keyPath)) {\r\n                        for (const idxKey of idx.keyPath) {\r\n                            if (!appIndex.keyPath.includes(idxKey)) {\r\n                                result.push(\r\n                                    this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, processingObject, \"IndexKeyPathMismatch\"));\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!appIndex.keyPath.includes(idx.keyPath)) {\r\n                            result.push(\r\n                                this.getFailureResult(`Index ${appIndex.name} keyPath does not match. Expected: ${appIndex.keyPath}, Actual: ${idx.keyPath}`, processingObject, \"IndexKeyPathMismatch\"));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private addNewStore(upgradeDB: IDBPDatabase, store: IStoreSchema, oldVersion: number, newVersion: number) {\r\n        const storeOutcomes: IndexedDBActionResult<any>[] = []\r\n        let primaryKey = store.primaryKey;\r\n\r\n        if (!primaryKey) {\r\n            primaryKey = { name: \"id\", keyPath: [\"id\"], auto: true, multiEntry: false, unique: true, keepAsArrayOnSingleValue: false };\r\n        }\r\n        const primaryKeyPath = primaryKey.keyPath.length == 1 ? primaryKey.keyPath[0] : primaryKey.keyPath;\r\n\r\n        try {\r\n\r\n            const newStore = upgradeDB.createObjectStore(store.name, { keyPath: primaryKeyPath, autoIncrement: primaryKey.auto });\r\n            const baseInfo: IndexedDBObjectBase = { databaseName: upgradeDB.name, storeName: store.name };\r\n            storeOutcomes.push(this.getSuccessResult(`Store ${store.name} created inside ${upgradeDB.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`, undefined, baseInfo, \"StoreCreated\"));\r\n            for (var index of store.indexes) {\r\n                storeOutcomes.push(this.createIndexForStore(index, newStore, oldVersion, newVersion));\r\n            }\r\n        }\r\n        catch (e) {\r\n            storeOutcomes.push(this.getFailureResult(`Error creating store ${store.name}: ${e}`, { databaseName: upgradeDB.name, storeName: store.name }, \"StoreCreationError\"));\r\n        }\r\n        return storeOutcomes;\r\n    }\r\n\r\n    private createIndexForStore(index: IIndexSpec, newStore: IDBPObjectStore<unknown, string[], string, \"versionchange\">, oldVersion: number, newVersion: number) {\r\n        let keyPath: string | string[] = index.keyPath;\r\n        if (index.keyPath.length === 1 && !index.keepAsArrayOnSingleValue) {\r\n            keyPath = index.keyPath[0];\r\n        }\r\n\r\n        if (index.multiEntry && index.keyPath.length > 1) {\r\n            return this.getFailureResult(`Index ${index.name} has multiEntry set to true but has multiple keyPaths. This is not supported.`, { databaseName: newStore.transaction.db.name, storeName: newStore.name }, \"MultiEntryIndexWithMultipleKeyPaths\");\r\n        }\r\n        if (index.multiEntry && index.keyPath.length === 1) {\r\n            //TODO: handle multiEntry indexes with multiple keyPaths\r\n            keyPath = index.keyPath[0];\r\n        }\r\n        try {\r\n            newStore.createIndex(index.name, keyPath, { unique: index.unique, multiEntry: index.multiEntry });\r\n        }\r\n        catch (e) {\r\n            return this.getFailureResult(`Error creating index ${index.name} for store ${newStore.name}: ${e}`, { databaseName: newStore.transaction.db.name, storeName: newStore.name }, \"IndexCreationError\");\r\n        }\r\n        const message = `Index ${index.name} created inside ${newStore.name} as it was missing when upgrading from v${oldVersion} to v${newVersion}`;\r\n        return this.getSuccessResult(message, undefined, { databaseName: \"\", storeName: newStore.name }, \"IndexCreated\");\r\n    }\r\n\r\n    private getSuccessResult<T extends any>(successMessage: string, data: T, requestBase: IndexedDBObjectBase, type: IndexedDBActionResultType): IndexedDBActionResultSuccess<T> {\r\n        const result: IndexedDBActionResultSuccess<T> = {\r\n            success: true,\r\n            result: {\r\n                data,\r\n                databaseName: requestBase.databaseName,\r\n                storeName: requestBase.storeName\r\n            },\r\n            message: successMessage,\r\n            type\r\n        }\r\n        if (this._sendNotifications) {\r\n            this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, result)\r\n            console.log(result);\r\n        }\r\n        return result;\r\n    }\r\n    private getFailureResult(errorMessage: string, requestBase: IndexedDBObjectBase, type: IndexedDBActionResultType): IndexedDBActionResultFailure {\r\n        const result: IndexedDBActionResultFailure = {\r\n            success: false,\r\n            result: {\r\n                data: undefined,\r\n                databaseName: requestBase.databaseName,\r\n                storeName: requestBase.storeName\r\n            },\r\n            message: errorMessage,\r\n            type\r\n        }\r\n        if (this._sendNotifications) {\r\n            this._dbManagerRef.invokeMethodAsync(RAISE_EVENT_METHOD, result)\r\n            console.log(result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private getInstance(dbName: string) {\r\n        return this.instances.find(i => i.name.toLowerCase() === dbName.toLowerCase())\r\n    }\r\n\r\n    private getInstanceExecutingCursor(instance: IIndexedDBDatabaseInstance, searchData: IndexedDBQuery) {\r\n        return instance.executingCursors.find(c =>\r\n            c.initialQuery.databaseName === searchData.databaseName &&\r\n            c.initialQuery.storeName === searchData.storeName &&\r\n            c.initialQuery.indexName === searchData.indexName &&\r\n            //Might not be the best idea or needed at all\r\n            JSON.stringify(c.initialQuery.queryValue) === JSON.stringify(searchData.queryValue)\r\n        );\r\n    }\r\n\r\n    private getQueryPath(searchData: IndexedDBQuery) {\r\n        return `${searchData.databaseName}->${searchData.storeName}${searchData.indexName ? `->${searchData.indexName}` : ``}`;\r\n    }\r\n\r\n    private getStoreNames(list: TypedDOMStringList<StoreNames<any>>) {\r\n        const names: string[] = [];\r\n        for (const storeName of list) {\r\n            names.push(storeName);\r\n        }\r\n        return names;\r\n    }\r\n\r\n    // private async ensureDatabaseOpen(dbName: string) {\r\n    //     let dbInstance = this.instances.find(i => i.name === dbName);\r\n    //     if (!dbInstance) {\r\n    //         dbInstance = {\r\n    //             name: dbName,\r\n    //             instance: await openDB(dbName)\r\n    //         }\r\n    //         this.instances.push(dbInstance);\r\n    //     }\r\n    //     return dbInstance.instance;\r\n    // }\r\n\r\n}", "\uFEFFimport { IndexedDbManager } from './indexedDbBlazor';\r\nimport { type DotNet } from \"@microsoft/dotnet-js-interop\";\r\nimport { IndexedDBJSConfig } from './models/InteropInterfaces';\r\n\r\nexport let IDBManager: IndexedDbManager | undefined;\r\nlet _dbManagerRef: DotNet.DotNetObject | undefined;\r\nexport function initIndexedDbManager(config: IndexedDBJSConfig) {\r\n    if (IDBManager) { return; }\r\n    IDBManager = new IndexedDbManager(config);\r\n    (window as any).dbManager = IDBManager;\r\n    _dbManagerRef = config.dotNetReference;\r\n    console.log(\"IndexedDbManager initialized\");\r\n}"],
  "mappings": "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",
  "names": ["target", "message"]
}
